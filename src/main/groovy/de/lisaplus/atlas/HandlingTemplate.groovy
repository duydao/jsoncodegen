package de.lisaplus.atlas

import de.lisaplus.atlas.builder.JsonSchemaBuilder
import de.lisaplus.atlas.codegen.GeneratorBase
import de.lisaplus.atlas.interf.IModelBuilder
import de.lisaplus.atlas.model.Model
import de.lisaplus.atlas.model.Property
import de.lisaplus.atlas.model.Type

class HandlingTemplate {

    static main(args) {

        // service service-junction
        def base = '/home/stefan/Entwicklung/service-junction/models/models-lisa-server/model/'
        def modelPath = args.length == 0 ?
                base + 'junction.json'
                // base + 'shared\\geo_point.json'
                : args[0]
        def typeName = args.length > 0 ?
                args[1]
                : 'JunctionJoined' // 'ObjectBase' // ''JunctionContact' // 'JunctionJoined' // 'JunctionLocationStreetsItem' // 'JunctionContactJoined' // 'Junction' // 'JunctionJoined' // 'JunctionNumber'  // 'Contact_type' // 'JunctionLocation' // 'JunctionContact'

        /*
        // service service-op-message
        def base = '/home/stefan/Entwicklung/service-op-message/models/models-lisa-server/model/'
        def modelPath = args.length == 0 ?
                base + 'op_message.json'
                : args[0]
        def typeName = args.length > 0 ?
                args[1]
                : 'ObjectGroup' // 'OpMessage' // 'OpMessageJoined'
        */

        /*
        // service incident
        def base = '/home/stefan/Entwicklung/service-op-message/models/models-lisa-server/model/'
        def modelPath = args.length == 0 ?
                base + 'incident.json'
                : args[0]
        def typeName = args.length > 0 ?
                args[1]
                : 'Incident' // 'ObjectBase'
        */


        def template = new HandlingTemplate(modelPath)
        template.execute(typeName, typeName.endsWith('Joined'))

        // Check for exception while running code generation for all available types
        // template.generateAll()
    }

    /** The path to the model definition file */
    String modelPath = modelPath
    /** The complete model with all types */
    Model model
    /** The bindings of the template / code generation */
    Map data
    /** Indicates whether the current type is a joined type */
    boolean joined
    /** The name of the Java class, which is being masked. */
    String targetType
    /** The main type, which is to be processed, mimic template environment */
    Type currentType
    /** This stack holds the property (names) visited while traversing the object hierarchy.*/
    List<Property> propStack = []
    /** Indicates that this property is an array. This sack is build while traversing the object hierarchy. */
    List<Boolean> propIsArrayStack = []
    /**
     * Indicates that this property or any of its parents was an array and that we therefore have to process an collection.
     * This sack is build while traversing the object hierarchy.
     */
    List<Boolean> propIsCollectionStack = []
    /** For caching the lines generated by the (recursive) closure calls of the model loops! */
    List<String> allLines = []
    /** For enabling/disabling debug output */
    boolean verbose = false

    HandlingTemplate(String modelPath) {
        this.modelPath = modelPath
        this.model = readModel(modelPath)
    }

    private Model readModel(String modelPath) {
        def modelFile = new File(modelPath)
        IModelBuilder builder = new JsonSchemaBuilder()
        return builder.buildModel(modelFile)
    }

    /**
     * Execute code generation for all types
     */
    void generateAll() {
        GeneratorBase generator = new DummyGenerator()
        // first process normal types
        this.model = readModel(modelPath)
        data = generator.createTemplateDataMap(model)
        def normalTypes = model.types.findAll { type -> !type.name.endsWith('Joined')}.collect()
        for (Type type : normalTypes) {
            executeForType(type, false)
        }
        // then reload model to erase effects of type tuning and process joined types
        this.model = readModel(modelPath)
        data = generator.createTemplateDataMap(model)
        def joinedTypes = model.types.findAll { type -> type.name.endsWith('Joined')}.collect()
        for (Type type : joinedTypes) {
            executeForType(type, true)
        }
    }

    /**
     * Prepares and triggers the code generation for one type
     * @param typeName The name of the type, which is to be processed
     * @param joined Indicates whether that type is a joined type
     */
    void execute(String typeName, boolean joined) {
        GeneratorBase generator = new DummyGenerator()
        data = generator.createTemplateDataMap(model)
        Type type = data.model.types.find {type -> type.name == typeName}
        executeForType(type, joined)
    }

    /**
     * <b>THIS METHOD ALTERS THE MODEL!!!</b>
     * This method tunes the properties of a (complex or reference) type and calls itself recursively if the type
     * itself holds properties of other (complex or reference) types.
     * Checks for properties with the tag <i>prepLookup</i> and
     * <ul>
     * <li>joined==true: removes the property completely</li>
     * <li>joined==false: removes the suffix Id</li>
     * @param type The type to process.
     */
    def tuneType = { Type type ->
        Closure<Void> action
        if (joined) {
            action = { Property prop ->
                println "// ATTENTION: Removing lookup property ${prop.name}"
                type.properties.remove(prop)
            }
        } else {
            action = { Property prop ->
                def orig = prop.name
                def shorten = prop.name.take(prop.name.length() - 2)
                println "// ATTENTION: Renaming lookup property from $orig to $shorten"
                prop.setName(shorten)
            }
        }
        Collection<Property> lookupProps = type.properties.findAll { Property prop -> prop.hasTag('prepLookup') && prop.name.endsWith('Id') }
        type.properties.findAll { Property prop -> prop.implicitRefIsRefType()   } each { Property prop -> tuneType.call(prop.implicitRef.type) }
        type.properties.findAll { Property prop -> prop.isRefTypeOrComplexType() } each { Property prop -> tuneType.call(prop.type.type) }
        lookupProps.each(action)
    }

    /* // mimic template
    // Create a private copy of the current type and alter that: tune prepLookup properties to loose suffix Id!
    def tunedType = copyType.call(currentType)
    tuneType.call(tunedType)
    */

    /**
     * Prepares the stacks for running the next loop over the model
     */
    def prepareStacks = {
        propStack.clear()
        propIsArrayStack.clear()
        // avoid extra case for handling empty stack!
        propIsCollectionStack = [false]
    }

    /**
     * Adds new elements to the stacks
     * @param property The property, which is to be visited
     */
    def putStacks = { Property property ->
        propStack.add(property)
        propIsArrayStack.add(property.type.isArray)
        // If either already collection of if this property is an collection.
        propIsCollectionStack.add(propIsCollectionStack.last() || property.type.isArray)
    }

    /**
     * Pops the latest elements from the stacks
     */
    def popStacks = {
        propStack.pop()
        propIsArrayStack.pop()
        propIsCollectionStack.pop()
    }

    /**
     * Processes a ref or complex property.
     * Take the property's type, looks through it properties and returns the one of type UUID.
     * That should usually be the entryId or guid!
     */
    def findIdProperty = { Property property ->
        Type type = property.type.type
        List candidates = type.properties.findAll { Property prop -> prop.type.name() == 'UUID'} // (${type.type.name()})
        if (candidates.isEmpty() && type.name == 'ListEntry') {
            // ListEntry usually have a StringType property refId (wanted) and text (to be avoided)
            candidates.addAll( type.properties.findAll { Property prop -> prop.type.name() == 'STRING' && prop.name == 'refId'} )
        }
        /*
        assert candidates.size() == 1 : "property=${property.name} type=${type.name} props=${type.properties.collect{ it.name }.join(', ')}"
        assert candidates[0].name == 'guid' || candidates[0].name == 'entryId' || candidates[0].name == 'refId'  : "property=${property.name} type=${type.name} props=${type.properties.collect{ it.name }.join(', ')}"
        */
        return candidates.isEmpty() ? null : candidates[0].name
    }

    /** Creates a key from current state of propStack, e.g. gis.area */
    Closure<String> currentKey = {
        return propStack.collect { prop -> prop.name}.join('.')
    }

    /**
     * Closure which actually looks for the array of ref or complex properties, for which a method removeXXX(pojo, UUID)
     * needs to be created. This closure calls itself recursively!
     */
    def evalDeepNestedListKeys = { Type type, List<String> keys ->
        // find all ref & complex properties, which are hold in arrays! These are the candidates for the methods removeXXX(pojo, UUID)
        type.properties.findAll{ Property prop -> prop.isRefTypeOrComplexType() && prop.type.isArray }.each { Property prop ->
            putStacks.call(prop)
            def key = currentKey.call()
            if (findIdProperty.call(prop)) {
                keys.add(key)
            } else {
                println "ATTENTION: Skip creating removeXXX(pojo, UUID) as property is missing proper ID: type=${currentType.name} key=${key}"
            }
            popStacks.call()
        }
        // recurse into all ref & complex properties, which are not hold in arrays!
        type.properties.findAll{ Property prop -> prop.isRefTypeOrComplexType() && !prop.type.isArray }.each { Property prop ->
            putStacks.call(prop)
            evalDeepNestedListKeys.call(prop.type.type, keys)
            popStacks.call()
        }
    }

    /**
     * Closure, which kicks off the search for the keys, which are candidates for the method removeXXX(pojo, UUID)
     * -> find array of ref or complex properties
     */
    def evalDeepNestedListKeysForType = { Type type ->
        // find keys for method removeXXX(pojo, UUID) -> find array of ref or complex properties
        List<String> keys = []
        prepareStacks.call()
        evalDeepNestedListKeys.call(type, keys)
        return keys
    }


    /**
     * Take a key / chain of property names, and builds a matching property stack. e.g location.streets
     */
    def propStackFromKey = { String key ->
        List localPropStack = []
        def curType = currentType
        def curProp
        for (String propName : key.split('\\.')) {
            curProp = curType.properties.find { it.name == propName }
            assert curProp && curProp.isRefTypeOrComplexType() : "propChain=${propChain} propName=${propName}"
            localPropStack.add(curProp)
            curType = curProp.type.type
        }
        return localPropStack
    }

    /**
     * Prints the method boolean addXXX(pojo, additional) associated with one key,
     * where the array property is a child of the main type
     */
    Closure<String> printAddForKeyShallow = { String key ->
        if (verbose) println "// printAddForKeyShallow for key $key"
        List<Property> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = data.upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = data.upperCamelCase.call(currentType.name)
        def upperLast = data.upperCamelCase.call(localPropStack.last().name)
        def ret = """
    /**
     * Tries to add a ${typeNameInner} object to a ${typeName}.
     * @param pojo the parent object to extend
     * @param additional The ${typeNameInner} object to add to the ${typeName}
     * @return <i>True</i>, if the ${typeNameInner} object could be added to the ${typeName},
     *         <i>false</i> otherwise.
     */
    public static boolean add${keyUpper}(final ${typeName} pojo, final ${typeNameInner} additional) {
        if (check${keyUpper}Exists(pojo)) {
            get${keyUpper}(pojo).add(additional);
            return true;
        }
        List<${typeNameInner}> list = new ArrayList<>();
        list.add(additional);
        pojo.set${upperLast}(list);
        return true;
    }"""
        return ret
    }

    /**
     * Prints the method boolean addXXX(pojo, additional) associated with one key
     * of a deep nested array property.
     */
    Closure<String> printAddForKeyDeep = { String key ->
        if (verbose) println "// printAddForKeyDeep for key $key"
        List<Property> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = data.upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = data.upperCamelCase.call(currentType.name)
        List<Property> parentStack = localPropStack.clone()
        parentStack.pop()
        def keyUpperParent = parentStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
        def upperSecondLast = data.upperCamelCase.call(parentStack.last().name)
        def upperLast = data.upperCamelCase.call(localPropStack.last().name)
        def ret = """
    /**
     * Tries to add a ${typeNameInner} object to a ${typeName}.
     * @param pojo the parent object to extend
     * @param additional The ${typeNameInner} object to add to the ${typeName}
     * @return <i>True</i>, if the ${typeNameInner} object could be added to the ${typeName},
     *         <i>false</i> otherwise.
     */
    public static boolean add${keyUpper}(final ${typeName} pojo, final ${typeNameInner} additional) {
        if (check${keyUpper}Exists(pojo)) {
            get${keyUpper}(pojo).add(additional);
            return true;
        }if (!check${keyUpperParent}Exists(pojo)) {
            return false;
        }
        List<${typeNameInner}> list = new ArrayList<>();
        list.add(additional);
        pojo.get${upperSecondLast}().set${upperLast}(list);
        return true;
    }"""
        return ret
    }

    /**
     * Prints the method boolean addXXX(pojo, additional) associated with one key.
     * Delegates to either to printAddForKeyShallow or to printAddForKeyDeep
     */
    Closure<String> printAddForKey = { String key ->
        int depth = key.split('\\.').size()
        if (depth == 1) {
            return printAddForKeyShallow.call(key)
        }
        return printAddForKeyDeep.call(key)
    }

    /**
     * Prints the method void addXXX(pojo, additional) throws MissingXXXException associated with one key.
     */
    Closure<String> printAddForKeyThrows = { String key ->
        /*
            public static void addObjectBaseTags(final JunctionJoined pojo, final ListEntry additional)
                    throws MissingParentException, MissingTargetException {
                ensureObjectBaseTagsExists(pojo, false);
                getObjectBaseTags(pojo).add(additional);
            }
         */
        if (verbose) println "// printAddForKeyThrows for key $key"
        List<Property> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = data.upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = data.upperCamelCase.call(currentType.name)
        def ret = """
    /**
     * Adds a ${typeNameInner} object to a ${typeName}.
     * @param pojo the parent object to extend
     * @param additional The ${typeNameInner} object to add to the ${typeName}
     * @throws MissingTargetException if the attribute holding the ${typeNameInner} objects is null
     * @throws MissingParentException if any parent of the attribute holding the ${typeNameInner} objects is missing.
     *             missing.
     */
    public static void add${keyUpper}(final ${typeName} pojo, final ${typeNameInner} additional)
            throws MissingParentException, MissingTargetException {
        ensure${keyUpper}Exists(pojo, false); 
        get${keyUpper}(pojo).add(additional);
    }"""
        return ret
    }

    /**
     * Prints the method void getXXX(pojo, UUID, replacement) throws MissingXXXException associated with one key
     * of a nested array property.
     */
    Closure<String> printGetForKeyThrows = { String key ->
        /*
            public static AddressPerson getAddressPersonsById(final JunctionContact pojo, final UUID targetId)
                    throws MissingParentException, MissingTargetException {
                final ListIterator<AddressPerson> iter = getAddressPersonsThrows(pojo).listIterator();
                while (iter.hasNext()) {
                    if (iter.next().getAddressId().equals(targetId.toString())) {
                        return iter.previous();
                    }
                }
                throw new MissingTargetException("address.persons", targetId);
            }
         */
        List<Property> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = data.upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = data.upperCamelCase.call(currentType.name)
        // usually one of entryId, guid or refId!
        def idProp = data.upperCamelCase.call(findIdProperty.call(localPropStack.last()))
        def ret = """
    /**
     * Returns a specific ${typeNameInner} object of a ${typeName}.
     * @param pojo The ${typeName} object to process
     * @param targetId The ID of the ${typeNameInner}, which is to be returned.
     * @throws MissingTargetException if no ${typeNameInner} of that id was found and subsequently returned,
     * @throws MissingParentException if the attribute holding the ${typeNameInner} objects or any of its parent objects is
     *             missing.
     */
    public static ${typeNameInner} get${keyUpper}ById(final ${typeName} pojo, final UUID targetId)
            throws MissingParentException, MissingTargetException {
        final ListIterator<${typeNameInner}> iter = get${keyUpper}Throws(pojo).listIterator();
        while (iter.hasNext()) {
            if (iter.next().get${idProp}().equals(targetId.toString())) {
                return iter.previous();
            }
        }
        throw new MissingTargetException("${key}", targetId);
    }"""
        return ret
    }

    /**
     * Prints the method boolean replaceXXX(pojo, UUID, replacement) associated with one key
     * of a nested array property.
     */
    Closure<String> printReplaceForKey = { String key ->
        List<Property> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = data.upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = data.upperCamelCase.call(currentType.name)
        // usually one of entryId, guid or refId!
        def idProp = data.upperCamelCase.call(findIdProperty.call(localPropStack.last()))
        def ret = """
    /**
     * Tries to replace a specific ${typeNameInner} object of a ${typeName}.
     * @param pojo The ${typeName} object to process
     * @param targetId The ID of the ${typeNameInner}, which is to be replaced.
     * @param replacement The ${typeNameInner} object to assign to the ${typeName}
     * @return <i>True</i>, if a ${typeNameInner} of that id was found and subsequently replaced,
     *         <i>false</i> if no object with that id could be found and therefore replaced.
     */
    public static boolean replace${keyUpper}ById(final ${typeName} pojo, final UUID targetId, final ${typeNameInner} replacement) {
        final ListIterator<${typeNameInner}> iter = get${keyUpper}(pojo).listIterator();
        while (iter.hasNext()) {
            if (iter.next().get${idProp}().equals(targetId.toString())) {
                iter.set(replacement);
                return true;
            }
        }
        return false;
    }"""
        return ret
    }

    /**
     * Prints the method void replaceXXX(pojo, UUID, replacement) throws MissingXXXException  associated with one key
     * of a nested array property.
     */
    Closure<String> printReplaceForKeyThrows = { String key ->
        /*
            public static void replaceObjectBaseTagsById(final JunctionJoined pojo, final UUID targetId,
                    final ListEntry replacement) throws MissingParentException, MissingTargetException {
                ensureObjectBaseTagsExists(pojo, true);
                final ListIterator<ListEntry> iter = getObjectBaseTags(pojo).listIterator();
                while (iter.hasNext()) {
                    if (iter.next().getRefId().equals(targetId.toString())) {
                        iter.set(replacement);
                        return;
                    }
                }
                throw new MissingTargetException("objectBase.tags", targetId);
            }
         */
        List<Property> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = data.upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = data.upperCamelCase.call(currentType.name)
        // usually one of entryId, guid or refId!
        def idProp = data.upperCamelCase.call(findIdProperty.call(localPropStack.last()))
        def ret = """
    /**
     * Replaces a specific ${typeNameInner} object of a ${typeName}.
     * @param pojo The ${typeName} object to process
     * @param targetId The ID of the ${typeNameInner}, which is to be replaced.
     * @param replacement The ${typeNameInner} object to assign to the ${typeName}
     * @throws MissingTargetException if no ${typeNameInner} of that id was found and subsequently replaced,
     * @throws MissingParentException if the attribute holding the ${typeNameInner} objects or any of its parent objects is
     *             missing.
     */
    public static void replace${keyUpper}ById(final ${typeName} pojo, final UUID targetId,
            final ${typeNameInner} replacement) throws MissingParentException, MissingTargetException {
        final ListIterator<${typeNameInner}> iter = get${keyUpper}Throws(pojo).listIterator();
        while (iter.hasNext()) {
            if (iter.next().get${idProp}().equals(targetId.toString())) {
                iter.set(replacement);
                return;
            }
        }
        throw new MissingTargetException("${key}", targetId);
    }"""
        return ret
    }

    /**
     * Prints the method boolean removeXXX(pojo, UUID) associated with one key
     * of a nested array property.
     */
    Closure<String> printRemoveForKey = { String key ->
        List<Property> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = data.upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = data.upperCamelCase.call(currentType.name)
        // usually one of entryId, guid or refId!
        def idProp = data.upperCamelCase.call(findIdProperty.call(localPropStack.last()))
        def ret = """
    /**
     * Tries to remove a specific ${typeNameInner} object from a ${typeName}.
     * @param pojo The object to process
     * @param targetId The ID of the ${typeNameInner}, which is to be removed.
     * @return <i>True</i>, if a ${typeNameInner} of that id was found and subsequently removed,
     *         <i>false</i> if no object with that id could be found and therefore removed.
     */
    public static boolean remove${keyUpper}ById(final ${typeName} pojo, final UUID targetId) {
        final Iterator<${typeNameInner}> iter = get${keyUpper}(pojo).iterator();
        while (iter.hasNext()) {
            if (iter.next().get${idProp}().equals(targetId.toString())) {
                iter.remove();
                return true;
            }
        }
        return false;
    }"""
        return ret
    }

    /**
     * Prints the method void removeXXX(pojo, UUID) associated with one key
     * of a nested array property.
     */
    Closure<String> printRemoveForKeyThrows = { String key ->
        /*
            public static void removeLocationStreetsById(final JunctionJoined pojo, final UUID targetId)
                    throws MissingParentException, MissingTargetException {
                ensureLocationStreetsExists(pojo, true);
                final Iterator<JunctionLocationStreetsItem> iter = getLocationStreets(pojo).iterator();
                while (iter.hasNext()) {
                    if (iter.next().getEntryId().equals(targetId.toString())) {
                        iter.remove();
                        return;
                    }
                }
                throw new MissingTargetException("location.streets", targetId);
            }
         */
        List<Property> localPropStack = propStackFromKey.call(key)
        def keyUpper = localPropStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = data.upperCamelCase.call(localPropStack.last().type.type.name)
        def typeName = data.upperCamelCase.call(currentType.name)
        // usually one of entryId, guid or refId!
        def idProp = data.upperCamelCase.call(findIdProperty.call(localPropStack.last()))
        def ret = """
    /**
     * Removes a specific ${typeNameInner} object from a ${typeName}.
     * @param pojo The object to process
     * @param targetId The ID of the ${typeNameInner}, which is to be removed.
     * @throws MissingTargetException if no ${typeNameInner} of that id was found and subsequently removed,
     * @throws MissingParentException if the attribute holding the ${typeNameInner} objects or any of its parent objects is
     *             missing.
     */
    public static void remove${keyUpper}ById(final ${typeName} pojo, final UUID targetId)
            throws MissingParentException, MissingTargetException {
        final Iterator<${typeNameInner}> iter = get${keyUpper}Throws(pojo).iterator();
        while (iter.hasNext()) {
            if (iter.next().get${idProp}().equals(targetId.toString())) {
                iter.remove();
                return;
            }
        }
        throw new MissingTargetException("${key}", targetId);
    }"""
        return ret
    }

    /**
     * Actually creates the case of the getValue method for properties of a complex or reference class.
     * @param prop The property to process
     * @param lines Where the created lines of code are to be added.
     */
    def createGetValueSimple = { Property property, List<String> lines ->
        def parentCollection = propIsCollectionStack.last()
        def parentProp = propStack.empty ? null : propStack.last()
        def propStackParent = []; propStackParent.addAll(propStack)
        putStacks.call(property)
        def key = propStack.collect {prop -> prop.name}.join('.')
        if (verbose) println "// key=${key} parentCollection=${parentCollection} parCollClass=${parentCollection.class.getName()}"
        if (propStack.size() == 1) {
            // in case of normal type and tag 'prepLookup' add suffix Id to method name -> getObjectBaseId()!
            def suffix = !joined && property.hasTag('prepLookup') ? 'Id' : ''
            lines.add("""        case "${key}":
            return pojo.get${data.firstUpperCase.call(property.name)}${suffix}();""" )
        } else if (parentCollection) {
            // parent is collection: stream collection, map to value, collect(Collectors.toList())
            /* Example
                case "objectBase.gis.area.points.lon":
                    return getObjectBaseGisAreaPoints(target).stream().map(p -> p.getLon()).collect(Collectors.toList());
             */
            String methodName = propStackParent.collect{ prop -> data.upperCamelCase.call(prop.name) }.join('')
            String parentChar = parentProp.name.take(1)
            lines.add("""        case "${key}":
            return get${methodName}(pojo).stream().map(${parentChar} -> ${parentChar}.get${data.upperCamelCase.call(property.name)}()).collect(Collectors.toList());""")
            // lines.add("""        case "${propStack.collect {prop -> prop.name}.join('.')}": return null; // TODO""" )
        } else {
            // parent not a collection: simple parent null check and return value
            /* Example:
                case "objectBase.gis.area.projection":
                    if (checkObjectBaseGisAreaExists(pojo)) {
                        return pojo.getObjectBase().getGis().getArea().getProjection();
                    } else {
                        return null;
                    }
             */
            String methodName = propStackParent.collect{ prop -> data.upperCamelCase.call(prop.name) }.join('')
            String getChain = propStack.collect{ prop -> data.upperCamelCase.call(prop.name) }.join('().get')

            lines.add("""        case "${key}":
            if (check${methodName}Exists(pojo)) {
                return pojo.get${getChain}();
            } else {
                return null;
            }""" )
        }
        popStacks.call()
    }

    /**
     * Creates the case statements of the getValue method for a certain type, calls itself recursively for reference
     * and complex types!
     * @param type The type to process
     * @param lines Where the created lines of code are to be added.
     */
    def createGetValueForType = { Type type, List<String> lines ->
        data.filterProps.call(type, [refComplex:false, withoutTag:'notDisplayed']).each { Property prop ->
            if (verbose) println "// createGetValueForType/RefTypeOrComplexType=false: type=${type.name} prop=${prop.name}"
            createGetValueSimple.call(prop, lines)
        }
        data.filterProps.call(type, [refComplex:true, withoutTag:'notDisplayed']).each { Property prop ->
            createGetValueSimple.call(prop, lines)
            // recursive call!
            putStacks.call(prop)
            createGetValueForType.call(prop.type.type, lines)
            popStacks.call()
        }
    }

    /**
     * Creates the content of the method ensureMatchingEntryId for a certain type, calls itself recursively for reference
     * and complex types!
     * @param type The type to process
     * @param lines Where the created lines of code are to be added.
     */
    Closure<Integer> createEnsureMatchingForType = { Type type, List<String> lines, int idx ->
        // Track the number of increments of idx!
        int incCount = 0
        if (propIsCollectionStack.last()) {
            Property pProp = propStack.last()
            boolean parentHasEntryId = pProp.isRefTypeOrComplexType() && pProp.type.type.properties.collect { prop2 -> prop2.name }.contains('entryId')
            if (parentHasEntryId) {
                /* Example
                final Iterator<AddressPerson> sourceIter1 = getAddressPersons(source).iterator();
                final Iterator<AddressPerson> targetIter1 = getAddressPersons(target).iterator();
                while(sourceIter1.hasNext()) {
                    targetIter1.next().setEntryId(sourceIter1.next().getEntryId());
                }
                */
                lines.add("        // found pProp=${pProp.name} type=${data.upperCamelCase.call(type.name)}")
                def jType = data.upperCamelCase.call(type.name)
                def methodName = propStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
                idx += 1
                incCount += 1
                lines.add(
                        """        final Iterator<${jType}> sourceIter${idx} = get${methodName}(source).iterator();
        final Iterator<${jType}> targetIter${idx} = get${methodName}(target).iterator();
        while(sourceIter${idx}.hasNext()) {
            targetIter${idx}.next().setEntryId(sourceIter1.next().getEntryId());
        }""")

            }
        }
        data.filterProps.call(type, [refComplex:true]).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            // idx may have been incremented 0 to n times by the recursive call!
            int recIncCount = createEnsureMatchingForType.call(prop.type.type, lines, idx)
            popStacks.call()
            idx += recIncCount
            incCount += recIncCount
        }
        return incCount
    }

    /**
     * Prints the methods ensureXXXExists(target, boolean) for a certain type, calls itself recursively for reference and complex types!
     * @param type The type to process
     */
    def printEnsureExistsForType = { Type type ->
        int size = propIsCollectionStack.size()
        if ( size > 2 && propIsCollectionStack.get(size-2)) {
            // can not check for null in children of array property -> stop creating more methods checkXXXExists()!
            return
        }
        if (!propStack.isEmpty()) {
            /*
                public static void ensureObjectBaseGisAreaPointsExists(JunctionJoined target, boolean isParent)
                        throws MissingParentException, MissingTargetException {
                    ensureObjectBaseGisAreaExists(target, true);
                    if (target.getObjectBase().getGis().getArea().getPoints() == null) {
                        if (isParent) {
                            throw new MissingParentException("objectBase.gis.area.points");
                        }
                        throw new MissingTargetException("objectBase.gis.area.points");
                    }
                }
             */
            def ensureMethodPart = propStack.collect{ data.upperCamelCase.call(it.name) }.join('')       // e.g. AddressPersonsContact
            def key = currentKey.call()
            List<String> getCalls = propStack.collect { "get${data.upperCamelCase.call(it.name)}()"}
            def getCall = getCalls.join('.')
            def parentCall
            int stackDim = propStack.size()
            if (stackDim == 1) {
                parentCall = ''
            } else {
                def ensureMethodPartParent = propStack.subList(0, stackDim-1).collect{ data.upperCamelCase.call(it.name) }.join('')
                parentCall = "\n        ensure${ensureMethodPartParent}Exists(target, false);"
            }
            def output = """
    /**
     * Before performing an operation on an attribute like e.g. replacing or removing it, this method checks whether
     * that attribute and all its parent objects actually exist.
     * @param target The object, which is to be processed.
     * @param isParent Indicates whether the attribute is regarded as the target of the operation. This parameter
     *            controls, which Exception is emitted when all parent objects are available but the attribute itself is
     *            missing!
     * @throws MissingTargetException If the attribute is missing and parameter <i>isParent</i> indicates that it is
     *             regarded as the target of the operation.
     * @throws MissingParentException If either any of the parent objects of the attribute is missing or if the
     *             attribute itself is missing and parameter <i>isParent</i> indicates that the attribute is not
     *             regarded as the target of the operation.
     */
    public static void ensure${ensureMethodPart}Exists(${targetType} target, boolean isParent)
            throws MissingParentException, MissingTargetException {${parentCall}
        if (target.${getCall} == null) {
            if (isParent) {
                throw new MissingParentException("${key}");
            }
            throw new MissingTargetException("${key}");
        }
    }"""
            println output
        }
        data.filterProps.call(type, [refComplex:true]).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            printEnsureExistsForType.call(prop.type.type)
            popStacks.call()
        }
    }

    /**
     * Prints the methods checkXXXExists(target) for a certain type, calls itself recursively for reference and complex types!
     * @param type The type to process
     */
    def printCheckExistsForType = { Type type ->
        int size = propIsCollectionStack.size()
        if ( size > 2 && propIsCollectionStack.get(size-2)) {
            // can not check for null in children of array property -> stop creating more methods checkXXXExists()!
            return
        }
        if (!propStack.isEmpty()) {
            /*
                public static boolean checkObjectBaseGisArea(JunctionNumberJoined target) {
                    return target.getObjectBase() != null
                            && target.getObjectBase().getGis() != null
                            && target.getObjectBase().getGis().getArea() != null;
                }
             */
            def checkMethodPart = propStack.collect{ data.upperCamelCase.call(it.name) }.join('')       // e.g. AddressPersonsContact
            // create longest getter call chain and then process it from one to all elements.
            List lines = []
            List getCalls = propStack.collect { "get${data.upperCamelCase.call(it.name)}()"}
            for (int i = 0; i < getCalls.size(); i++) {
                def cond = getCalls.subList(0, i+1).join('.')
                lines.add("target.${cond} != null")
            }
            def conditions = lines.join('\n                && ')
            def output = """
    /**
     * @param target The object, which is to be processed.
     * @return <i>True</i>, if the attribute and all its parents exist, <i>false</i> otherwise.
     */
    public static boolean check${checkMethodPart}Exists(${targetType} target) {
        return ${conditions};
    }"""
            println output
        }

//        type.properties.findAll { prop -> return prop.isRefTypeOrComplexType() }.each { prop ->
        data.filterProps.call(type, [refComplex:true]).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            printCheckExistsForType.call(prop.type.type)
            popStacks.call()
        }
    }

    /**
     * Prints the methods getXXX(target) for a certain type, calls itself recursively for reference and complex types!
     * @param type The type to process
     */
    def printGetForType = { Type type ->
        if (propIsCollectionStack.last()) {
            // Example for key address.persons.contact where persons is the only array type
            // In case of multiple array types use .flatMap() for 2. to last array type!
            // We can not check for null references for objects in the object tree after hitting the first array property.
            // ->
            // A: the method checkXXXExists only checks for null references up to the first array property.
            // B: do use Stream.filter() with a predicate for filtering out the null references!
            /*
                public static static List<ContactData> getAddressPersonsContact(JunctionContactJoined target) {
                    if (checkAddressPersonsExists(target)) {
                        return target.getAddress().getPersons().stream()
                                                               .filter(p -> p.getContact() != null)
                                                               .map(p -> p.getContact())
                                                               .collect(Collectors.toList());
                    }
                    return Collections.emptyList();
                }
             */
            def methodName = propStack.subList(0, propStack.size()).collect { data.upperCamelCase.call(it.name) }.join('') // e.g. AddressPersonsContact
            int maxCheckProp = propIsCollectionStack.last() ? propIsCollectionStack.indexOf(Boolean.TRUE) : propStack.size() // The index of the first entry of propIsCollectionStack indicating value collection
            def checkName = propStack.subList(0, maxCheckProp).collect { data.upperCamelCase.call(it.name) }.join('') // e.g. AddressPersons

            // iterate through propStack and propIsArrayStack
            // Before first array type is encountered, add getter calls
            // When first array type is encountered, add .stream() and switch mode to .map(...)
            // Whenever another array type is encountered, use .flatMap(...) instead of .map(...)
            List parts = []
            boolean useGetter = true
            for (int i = 0; i < propStack.size(); i++) {
                def currUpper = data.upperCamelCase.call(propStack[i].name)
                if (useGetter) {
                    // getXXX()
                    parts.add("get${currUpper}()")
                } else {
                    // TODO Teach Eiko and Stephan
                    def parentProp = propStack[i-1].name.take(1)
                    if (propIsArrayStack[i]) {
                        // flatMap(), e.g. flatMap(contact -> contact.getEmail().stream())
                        parts.add("filter(${parentProp} -> ${parentProp}.get${currUpper}() != null)")
                        parts.add("flatMap(${parentProp} -> ${parentProp}.get${currUpper}().stream())")
                    } else {
                        // map(), e.g. map(person -> person.getContact())
                        parts.add("filter(${parentProp} -> ${parentProp}.get${currUpper}() != null)")
                        parts.add("map(${parentProp} -> ${parentProp}.get${currUpper}())")
                    }
                }
                if (useGetter && propIsArrayStack[i]) {
                    parts.add("stream()")
                    useGetter = false
                }
            }
            parts.add('collect(Collectors.toList())')

            // If the very last entry is the first array type, then these is no need to appending
            // .stream() and .collect(Collectors.toList()) -> just discard these two entries!
            if (parts[parts.size()-2] == "stream()") {
                parts = parts.subList(0, parts.size() - 2)
            }
            def retType = data.upperCamelCase.call(type.name)
            def stream = parts[0] + parts.subList(1,parts.size()).collect {"\n                    .$it"}.join('')
            def output = """
    /**
     * This method is lenient: It will always return at least an empty list, even if the parent objects of the
     * ${retType} are missing. Actions performed on the returned list will not change the state of the ${targetType}
     * object, changes to the ${retType} objects itself do change the ${targetType} object!
     * @param target The ${targetType} object to process
     * @return The ${retType} objects hold by the ${targetType} or an empty list, if the attribute holding the
     *         ${retType} objects or any of its parent objects is missing.
     */
    public static List<${retType}> get${methodName}(${targetType} target) {
        if (check${checkName}Exists(target)) {
            return target.${stream};
        }
        return Collections.emptyList();
    }"""
            println output
        }

//        type.properties.findAll { prop -> return prop.isRefTypeOrComplexType() }.each { prop ->
        data.filterProps.call(type, [refComplex:true]).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            printGetForType.call(prop.type.type)
            popStacks.call()
        }
    }
    /**
     * Prints the methods getXXXThrows(target) for a certain type, calls itself recursively for reference and complex types!
     * @param type The type to process
     */
    def printGetThrowsForType = { Type type ->
        if (propIsCollectionStack.last()) {
            // Example for key address.persons.contact where persons is the only array type
            // In case of multiple array types use .flatMap() for 2. to last array type!
            // We can not check for null references for objects in the object tree after hitting the first array property.
            // ->
            // A: the method checkXXXExists only checks for null references up to the first array property.
            // B: do use Stream.filter() with a predicate for filtering out the null references!
            /*
                public static List<ContactData> getAddressPersonsContactThrows(JunctionContact target) throws MissingParentException {
                    // Assumption: List attributes are never null, only empty!
                    ensureAddressPersonsExists(target, true);
                    return target.getAddress()
                            .getPersons()
                            .stream()
                            .filter(p -> p.getContact() != null)
                            .map(p -> p.getContact())
                            .collect(Collectors.toList());
                }
             */
            def methodName = propStack.subList(0, propStack.size()).collect { data.upperCamelCase.call(it.name) }.join('') // e.g. AddressPersonsContact
            int maxCheckProp = propIsCollectionStack.last() ? propIsCollectionStack.indexOf(Boolean.TRUE) : propStack.size() // The index of the first entry of propIsCollectionStack indicating value collection
            def checkName = propStack.subList(0, maxCheckProp).collect { data.upperCamelCase.call(it.name) }.join('') // e.g. AddressPersons

            // iterate through propStack and propIsArrayStack
            // Before first array type is encountered, add getter calls
            // When first array type is encountered, add .stream() and switch mode to .map(...)
            // Whenever another array type is encountered, use .flatMap(...) instead of .map(...)
            List parts = []
            boolean useGetter = true
            for (int i = 0; i < propStack.size(); i++) {
                def currUpper = data.upperCamelCase.call(propStack[i].name)
                if (useGetter) {
                    // getXXX()
                    parts.add("get${currUpper}()")
                } else {
                    // TODO Teach Eiko and Stephan
                    def parentProp = propStack[i-1].name.take(1)
                    if (propIsArrayStack[i]) {
                        // flatMap(), e.g. flatMap(contact -> contact.getEmail().stream())
                        parts.add("filter(${parentProp} -> ${parentProp}.get${currUpper}() != null)")
                        parts.add("flatMap(${parentProp} -> ${parentProp}.get${currUpper}().stream())")
                    } else {
                        // map(), e.g. map(person -> person.getContact())
                        parts.add("filter(${parentProp} -> ${parentProp}.get${currUpper}() != null)")
                        parts.add("map(${parentProp} -> ${parentProp}.get${currUpper}())")
                    }
                }
                if (useGetter && propIsArrayStack[i]) {
                    parts.add("stream()")
                    useGetter = false
                }
            }
            parts.add('collect(Collectors.toList())')

            // If the very last entry is the first array type, then these is no need to appending
            // .stream() and .collect(Collectors.toList()) -> just discard these two entries!
            if (parts[parts.size()-2] == "stream()") {
                parts = parts.subList(0, parts.size() - 2)
            }
            def retType = data.upperCamelCase.call(type.name)
            def stream = parts[0] + parts.subList(1,parts.size()).collect {"\n                    .$it"}.join('')
            def output = """
    /**
     * Actions performed on the returned list will not change the state of the ${targetType} object, changes to the
     * ${retType} objects itself do change the ${targetType} object!
     * @param target The ${targetType} object to process
     * @return The ${retType} objects hold by the ${targetType}
     * @throws MissingParentException if the attribute holding the ${retType} objects or any of its parent objects are
     *             missing.
     */
    public static List<${retType}> get${methodName}Throws(${targetType} target) throws MissingParentException {
        // Assumption: List attributes are never null, only empty!
        ensure${checkName}Exists(target,true);
        return target.${stream};
    }"""
            println output
        }

//        type.properties.findAll { prop -> return prop.isRefTypeOrComplexType() }.each { prop ->
        data.filterProps.call(type, [refComplex:true]).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            printGetThrowsForType.call(prop.type.type)
            popStacks.call()
        }
    }

    /**
     * Performs the actual code generation for one type
     * @param type The type, which ist to be processed
     * @param joined Indicates, whether that type is a joined type (contains a property of the type ObjectBase)
     */
    private void executeForType(Type type, boolean joined) {
        this.joined = joined
        targetType = data.upperCamelCase.call(type.name)
        currentType = type
        println '###################################################################'
        println "Start of $targetType:"
        println '###################################################################'

        Type tunedType = data.copyType.call(currentType)
        tuneType.call(tunedType)

        // find keys for method removeXXX(pojo, UUID) -> find array of ref or complex properties
        List<String> deepNestedListKeys = evalDeepNestedListKeysForType.call(tunedType)
        println "type=${currentType.name} deepNestedListKeys=${deepNestedListKeys}"

        // start printing class content
        String fileHead = """
/*********start*********/
package de.lisaplus.lisa.junction.model.handling;

/**
 * This file is generated by jsonCodeGen. Changes will be overwritten with next code generation run.
 * Template: handling.txt
 */

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.UUID;
import java.util.stream.Collectors;

import de.lisaplus.lisa.junction.model.*;
import de.schlothauer.services.exceptions.*;

/**
 * This class contains the Unit test for masking of class $targetType. 
 */
public class ${targetType}Handling {"""

        println fileHead

        println """
    /**
     * For restoring of array properties with entryId attributes these entryId values need to match.
     * This method assumes that array dimension of objects <i>source</i> and <i>target</i> match!
     * @param source The object, which defines the entryId values
     * @param target The object, which is to inherit the entryId values.
     */
    public static void ensureMatchingEntryId(final ${targetType} source, final ${targetType} target) {"""
        allLines.clear()
        prepareStacks.call()
        createEnsureMatchingForType.call(tunedType, allLines, 0)
        allLines.each { line -> println line }
        println """    }

    /**
     * Returns the value(s) associated with a mask key.
     * @param pojo The object to process
     * @param maskKey The mask key to process.
     * @return The value(s) associated with a mask key.
     */
    public static Object getValue(final ${targetType} pojo, final String maskKey) {
        switch(maskKey) {"""
        allLines.clear()
        prepareStacks.call()
        createGetValueForType.call(tunedType, allLines)
        allLines.each { line -> println line }
        println """
        default:
            throw new RuntimeException(String.format("Unsupported mask key '%s'!", maskKey));
        }
    }"""
        /* 1st loop: method checkXXXExists() */
        prepareStacks.call()
        printCheckExistsForType.call(tunedType)

        /* 2nd loop: methods ensureXXXExists() */
        prepareStacks.call()
        printEnsureExistsForType.call(tunedType)

        /* 3rd loop: method getXXX() */
        prepareStacks.call()
        printGetForType.call(tunedType)

        /* 4th loop: method getXXXTrhows() */
        prepareStacks.call()
        printGetThrowsForType.call(tunedType)

        for(String key : deepNestedListKeys) {
            println printAddForKeyThrows.call(key)
            println printGetForKeyThrows.call(key)
            println printReplaceForKeyThrows.call(key)
            println printRemoveForKeyThrows.call(key)
        }

        println '}\n'
    }   // end of executeForType

}
