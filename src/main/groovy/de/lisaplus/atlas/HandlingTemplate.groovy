package de.lisaplus.atlas

import de.lisaplus.atlas.builder.JsonSchemaBuilder
import de.lisaplus.atlas.codegen.GeneratorBase
import de.lisaplus.atlas.interf.IModelBuilder
import de.lisaplus.atlas.model.Model
import de.lisaplus.atlas.model.Property
import de.lisaplus.atlas.model.Type

class HandlingTemplate {

    static main(args) {

        // service service-junction
        def base = '/home/stefan/Entwicklung/service-junction/models/models-lisa-server/model/'
        def modelPath = args.length == 0 ?
                base + 'junction.json'
                // base + 'shared\\geo_point.json'
                : args[0]
        def typeName = args.length > 0 ?
                args[1]
                : 'JunctionContact' // 'JunctionJoined' // 'JunctionLocationStreetsItem' // 'JunctionContactJoined' // 'Junction' // 'JunctionJoined' // 'JunctionNumber'  // 'Contact_type' // 'JunctionLocation' // 'JunctionContact'

        /*
        // service service-op-message
        def base = '/home/stefan/Entwicklung/service-op-message/models/models-lisa-server/model/'
        def modelPath = args.length == 0 ?
                base + 'op_message.json'
                : args[0]
        def typeName = args.length > 0 ?
                args[1]
                : 'ObjectGroup' // 'OpMessage' // 'OpMessageJoined'
        */

        /*
        // service incident
        def base = '/home/stefan/Entwicklung/service-op-message/models/models-lisa-server/model/'
        def modelPath = args.length == 0 ?
                base + 'incident.json'
                : args[0]
        def typeName = args.length > 0 ?
                args[1]
                : 'Incident' // 'ObjectBase'
        */


        def template = new HandlingTemplate(modelPath)
        template.execute(typeName, typeName.endsWith('Joined'))

        // Check for exception while running code generation for all available types
        // template.generateAll()
    }

    /** The path to the model definition file */
    String modelPath = modelPath
    /** The complete model with all types */
    Model model
    /** The bindings of the template / code generation */
    Map data
    /** Indicates whether the current type is a joined type */
    boolean joined
    /** The name of the Java class, which is being masked. */
    String targetType
    /** The main type, which is to be processed, mimic template environment */
    Type currentType
    /** This stack holds the property (names) visited while traversing the object hierarchy.*/
    List<Property> propStack = []
    /** Indicates that this property is an array. This sack is build while traversing the object hierarchy. */
    List<Boolean> propIsArrayStack = []
    /**
     *  Indicates that this property or any of its parents was an array and that we therefore have to process an collection.
     *  This sack is build while traversing the object hierarchy.
     */
    List<Boolean> propIsCollectionStack = []
    /** For caching the lines generated by the (recursive) closure calls of the model loops! */
    List<String> allLines = []
    /** For enabling/disabling debug output */
    boolean verbose = false

    HandlingTemplate(String modelPath) {
        this.modelPath = modelPath
        this.model = readModel(modelPath)
    }

    private Model readModel(String modelPath) {
        def modelFile = new File(modelPath)
        IModelBuilder builder = new JsonSchemaBuilder()
        return builder.buildModel(modelFile)
    }

    /**
     * Execute code generation for all types
     */
    void generateAll() {
        GeneratorBase generator = new DummyGenerator()
        // first process normal types
        this.model = readModel(modelPath)
        data = generator.createTemplateDataMap(model)
        def normalTypes = model.types.findAll { type -> !type.name.endsWith('Joined')}.collect()
        for (Type type : normalTypes) {
            executeForType(type, false)
        }
        // then reload model to erase effects of type tuning and process joined types
        this.model = readModel(modelPath)
        data = generator.createTemplateDataMap(model)
        def joinedTypes = model.types.findAll { type -> type.name.endsWith('Joined')}.collect()
        for (Type type : joinedTypes) {
            executeForType(type, true)
        }
    }

    /**
     * Prepares and triggers the code generation for one type
     * @param typeName The name of the type, which is to be processed
     * @param joined Indicates whether that type is a joined type
     */
    void execute(String typeName, boolean joined) {
        GeneratorBase generator = new DummyGenerator()
        data = generator.createTemplateDataMap(model)
        Type type = data.model.types.find {type -> type.name == typeName}
        executeForType(type, joined)
    }

    /**
     * <b>THIS METHOD ALTERS THE MODEL!!!</b>
     * This method tunes the properties of a (complex or reference) type and calls itself recursively if the type
     * itself holds properties of other (complex or reference) types.
     * Checks for properties with the tag <i>prepLookup</i> and
     * <ul>
     * <li>joined==true: removes the property completely</li>
     * <li>joined==false: removes the suffix Id</li>
     * @param type The type to process.
     */
    def tuneType = { Type type ->
        Closure<Void> action
        if (joined) {
            action = { Property prop ->
                println "// ATTENTION: Removing lookup property ${prop.name}"
                type.properties.remove(prop)
            }
        } else {
            action = { Property prop ->
                def orig = prop.name
                def shorten = prop.name.take(prop.name.length() - 2)
                println "// ATTENTION: Renaming lookup property from $orig to $shorten"
                prop.setName(shorten)
            }
        }
        Collection<Property> lookupProps = type.properties.findAll { Property prop -> prop.hasTag('prepLookup') && prop.name.endsWith('Id') }
        type.properties.findAll { Property prop -> prop.implicitRefIsRefType()   } each { Property prop -> tuneType.call(prop.implicitRef.type) }
        type.properties.findAll { Property prop -> prop.isRefTypeOrComplexType() } each { Property prop -> tuneType.call(prop.type.type) }
        lookupProps.each(action)
    }

    /* // mimic template
    // Create a private copy of the current type and alter that: tune prepLookup properties to loose suffix Id!
    def tunedType = copyType.call(currentType)
    tuneType.call(tunedType)
    */

    /**
     * Prepares the stacks for running the next loop over the model
     */
    def prepareStacks = {
        propStack.clear()
        propIsArrayStack.clear()
        // avoid extra case for handling empty stack!
        propIsCollectionStack = [false]
    }

    /**
     * Adds new elements to the stacks
     * @param property The property, which is to be visited
     */
    def putStacks = { Property property ->
        propStack.add(property)
        propIsArrayStack.add(property.type.isArray)
        // If either already collection of if this property is an collection.
        propIsCollectionStack.add(propIsCollectionStack.last() || property.type.isArray)
    }

    /**
     * Pops the latest elements from the stacks
     */
    def popStacks = {
        propStack.pop()
        propIsArrayStack.pop()
        propIsCollectionStack.pop()
    }

    /** Creates a key from current state of propStack, e.g. gis.area */
    Closure<String> currentKey = {
        return propStack.collect { prop -> prop.name}.join('.')
    }

    /**
     * Closure which actually looks for the array of ref or complex properties, for which a method removeXXX(pojo, UUID)
     * needs to be created. This closure calls itself recursively!
     */
    def evalRemoveKeys = { Type type, List<String> keys ->
        // find all ref & complex properties, which are hold in arrays! These are the candidates for the methods removeXXX(pojo, UUID)
        type.properties.findAll{ Property prop -> prop.isRefTypeOrComplexType() && prop.type.isArray }.each { Property prop ->
            putStacks.call(prop)
            def key = currentKey.call()
            if (findIdProperty.call(prop)) {
                keys.add(key)
            } else {
                println "ATTENTION: Skip creating removeXXX(pojo, UUID) as property is missing proper ID: type=${currentType.name} key=${key}"
            }
            popStacks.call()
        }
        // recurse into all ref & complex properties, which are not hold in arrays!
        data.findPro
        type.properties.findAll{ Property prop -> prop.isRefTypeOrComplexType() && !prop.type.isArray }.each { Property prop ->
            putStacks.call(prop)
            evalRemoveKeys.call(prop.type.type, keys)
            popStacks.call()
        }
    }

    /**
     * Closure, which kicks off the search for the keys, which are candidates for the method removeXXX(pojo, UUID)
     * -> find array of ref or complex properties
     */
    def evalRemoveKeysForType = { Type type ->
        // find keys for method removeXXX(pojo, UUID) -> find array of ref or complex properties
        List<String> keys = []
        prepareStacks.call()
        evalRemoveKeys.call(type, keys)
        return keys
    }

    /**
     * Take a key / chain of property names, and builds a matching property stack. e.g location.streets
     */
    def propStackFromKey = { String key ->
        List propStack = []
        def curType = currentType
        def curProp
        for (String propName : key.split('\\.')) {
            curProp = curType.properties.find { it.name == propName }
            assert curProp && curProp.isRefTypeOrComplexType() : "propChain=${propChain} propName=${propName}"
            propStack.add(curProp)
            curType = curProp.type.type
        }
        return propStack
    }

    /**
     * Processes a ref or complex property.
     * Take the property's type, looks through it properties and returns the one of type UUID.
     * That should usually be the entryId or guid!
     */
    def findIdProperty = { Property property ->
        Type type = property.type.type
        List candidates = type.properties.findAll { Property prop -> prop.type.name() == 'UUID'} // (${type.type.name()})
        if (candidates.isEmpty() && type.name == 'ListEntry') {
            // ListEntry usually have a StringType property refId (wanted) and text (to be avoided)
            candidates.addAll( type.properties.findAll { Property prop -> prop.type.name() == 'STRING' && prop.name == 'refId'} )
        }
        /*
        assert candidates.size() == 1 : "property=${property.name} type=${type.name} props=${type.properties.collect{ it.name }.join(', ')}"
        assert candidates[0].name == 'guid' || candidates[0].name == 'entryId' || candidates[0].name == 'refId'  : "property=${property.name} type=${type.name} props=${type.properties.collect{ it.name }.join(', ')}"
        */
        return candidates.isEmpty() ? null : candidates[0].name
    }

    /**
     * Prints the method removeXXX(pojo, UUID) associated with one key
     */
    Closure<String> printRemoveForKey = { String key ->
        List<Property> propStack = propStackFromKey.call(key)
        def keyUpper = propStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
        def typeNameInner = data.upperCamelCase.call(propStack.last().type.type.name)
        def typeName = data.upperCamelCase.call(currentType.name)
        // usually one of entryId, guid or refId!
        def idProp = data.upperCamelCase.call(findIdProperty.call(propStack.last()))
        def ret = """
    /**
     * Tries to remove a specific ${typeNameInner} object from a ${typeName}.
     * @param pojo The object to process
     * @param targetId The ID of the ${typeNameInner}, which is to be removed.
     * @return <i>True</i>, if a ${typeNameInner} of that id was found and subsequently removed,
     *         <i>false</i> if no object with that id could be found and therefore removed.
     */
    public static boolean remove${keyUpper}ById(${typeName} pojo, UUID targetId) {
        final Iterator<${typeNameInner}> iter = get${keyUpper}(pojo).iterator();
        while (iter.hasNext()) {
            if (iter.next().get${idProp}().equals(targetId.toString())) {
                iter.remove();
                return true;
            }
        }
        return false;
    }"""
        return ret
    }

    /**
     * Actually creates the case of the getValue method for properties of a complex or reference class.
     * @param prop The property to process
     * @param lines Where the created lines of code are to be added.
     */
    def createGetValueSimple = { Property property, List<String> lines ->
        def parentCollection = propIsCollectionStack.last()
        def parentProp = propStack.empty ? null : propStack.last()
        def propStackParent = []; propStackParent.addAll(propStack)
        putStacks.call(property)
        def key = propStack.collect {prop -> prop.name}.join('.')
        if (verbose)  println "key=${key} parentCollection=${parentCollection} parCollClass=${parentCollection.class.getName()}"
        if (propStack.size() == 1) {
            // in case of normal type and tag 'prepLookup' add suffix Id to method name -> getObjectBaseId()!
            def suffix = !joined && property.hasTag('prepLookup') ? 'Id' : ''
            lines.add("""        case "${key}":
            return pojo.get${data.firstUpperCase.call(property.name)}${suffix}();""" )
        } else if (parentCollection) {
            // parent is collection: stream collection, map to value, collect(Collectors.toList())
            /* Example
                case "objectBase.gis.area.points.lon":
                    return getObjectBaseGisAreaPoints(target).stream().map(p -> p.getLon()).collect(Collectors.toList());
             */
            String methodName = propStackParent.collect{ prop -> data.upperCamelCase.call(prop.name) }.join('')
            String parentChar = parentProp.name.take(1)
            lines.add("""        case "${key}":
            return get${methodName}(pojo).stream().map(${parentChar} -> ${parentChar}.get${data.upperCamelCase.call(property.name)}()).collect(Collectors.toList());""")
            // lines.add("""        case "${propStack.collect {prop -> prop.name}.join('.')}": return null; // TODO""" )
        } else {
            // parent not a collection: simple parent null check and return value
            /* Example:
                case "objectBase.gis.area.projection":
                    if (checkObjectBaseGisAreaExists(pojo)) {
                        return pojo.getObjectBase().getGis().getArea().getProjection();
                    } else {
                        return null;
                    }
             */
            String methodName = propStackParent.collect{ prop -> data.upperCamelCase.call(prop.name) }.join('')
            String getChain = propStack.collect{ prop -> data.upperCamelCase.call(prop.name) }.join('().get')

            lines.add("""        case "${key}":
            if (check${methodName}Exists(pojo)) {
                return pojo.get${getChain}();
            } else {
                return null;
            }""" )
        }
        popStacks.call()
    }

    /**
     * Creates the case statements of the getValue method for a certain type, calls itself recursively for reference
     * and complex types!
     * @param type The type to process
     * @param lines Where the created lines of code are to be added.
     */
    def createGetValueForType = { Type type, List<String> lines ->
        data.filterProps.call(type, [refComplex:false, withoutTag:'notDisplayed']).each { Property prop ->
            if (verbose)  println "// createGetValueForType/RefTypeOrComplexType=false: type=${type.name} prop=${prop.name}"
            createGetValueSimple.call(prop, lines)
        }
        data.filterProps.call(type, [refComplex:true, withoutTag:'notDisplayed']).each { Property prop ->
            createGetValueSimple.call(prop, lines)
            // recursive call!
            putStacks.call(prop)
            createGetValueForType.call(prop.type.type, lines)
            popStacks.call()
        }
    }

    /**
     * Creates the content of the method ensureMatchingEntryId for a certain type, calls itself recursively for reference
     * and complex types!
     * @param type The type to process
     * @param lines Where the created lines of code are to be added.
     */
    Closure<Integer> createEnsureMatchingForType = { Type type, List<String> lines, int idx ->
        // Track the number of increments of idx!
        int incCount = 0
        if (propIsCollectionStack.last()) {
            Property pProp = propStack.last()
            boolean parentHasEntryId = pProp.isRefTypeOrComplexType() && pProp.type.type.properties.collect { prop2 -> prop2.name }.contains('entryId')
            if (parentHasEntryId) {
                /* Example
                final Iterator<AddressPerson> sourceIter1 = getAddressPersons(source).iterator();
                final Iterator<AddressPerson> targetIter1 = getAddressPersons(target).iterator();
                while(sourceIter1.hasNext()) {
                    targetIter1.next().setEntryId(sourceIter1.next().getEntryId());
                }
                */
                lines.add("        // found pProp=${pProp.name} type=${data.upperCamelCase.call(type.name)}")
                def jType = data.upperCamelCase.call(type.name)
                def methodName = propStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
                idx += 1
                incCount += 1
                lines.add(
                        """        final Iterator<${jType}> sourceIter${idx} = get${methodName}(source).iterator();
        final Iterator<${jType}> targetIter${idx} = get${methodName}(target).iterator();
        while(sourceIter${idx}.hasNext()) {
            targetIter${idx}.next().setEntryId(sourceIter1.next().getEntryId());
        }""")

            }
        }
        data.filterProps.call(type, [refComplex:true]).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            // idx may have been incremented 0 to n times by the recursive call!
            int recIncCount = createEnsureMatchingForType.call(prop.type.type, lines, idx)
            popStacks.call()
            idx += recIncCount
            incCount += recIncCount
        }
        return incCount
    }

    /**
     * Prints the methods checkXXX(target) for a certain type, calls itself recursively for reference and complex types!
     * @param type The type to process
     */
    def printCheckExistsForType = { Type type ->
        int size = propIsCollectionStack.size()
        if ( size > 2 && propIsCollectionStack.get(size-2)) {
            // can not check for null in children of array property -> stop creating more methods checkXXXExists()!
            return
        }
        if (!propStack.isEmpty()) {
            /*
                public static boolean checkObjectBaseGisArea(JunctionNumberJoined target) {
                    return target.getObjectBase() != null
                            && target.getObjectBase().getGis() != null
                            && target.getObjectBase().getGis().getArea() != null;
                }
             */
            def checkMethodPart = propStack.collect{ data.upperCamelCase.call(it.name) }.join('')       // e.g. AddressPersonsContact
            // create longest getter call chain and then process it from one to all elements.
            List lines = []
            List getCalls = propStack.collect { "get${data.upperCamelCase.call(it.name)}()"}
            for (int i = 0; i < getCalls.size(); i++) {
                def cond = getCalls.subList(0, i+1).join('.')
                lines.add("target.${cond} != null")
            }
            def conditions = lines.join('\n                && ')
            def output = "\n    public static boolean check${checkMethodPart}Exists(${targetType} target) {\n        return ${conditions};\n    }"
            println output
        }

//        type.properties.findAll { prop -> return prop.isRefTypeOrComplexType() }.each { prop ->
        data.filterProps.call(type, [refComplex:true]).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            printCheckExistsForType.call(prop.type.type)
            popStacks.call()
        }
    }

    /**
     * Prints the methods checkXXX(target) for a certain type, calls itself recursively for reference and complex types!
     * @param type The type to process
     */
    def printGetForType = { Type type ->
        if (propIsCollectionStack.last()) {
            // Example for key address.persons.contact where persons is the only array type
            // In case of multiple array types use .flatMap() for 2. to last array type!
            // We can not check for null references for objects in the object tree after hitting the first array property.
            // ->
            // A: the method checkXXXExists only checks for null references up to the first array property.
            // B: do use Stream.filter() with a predicate for filtering out the null references!
            /*
                public static static List<ContactData> getAddressPersonsContact(JunctionContactJoined target) {
                    if (checkAddressPersonsExists(target)) {
                        return target.getAddress().getPersons().stream()
                                                               .filter(p -> p.getContact() != null)
                                                               .map(p -> p.getContact())
                                                               .collect(Collectors.toList());
                    }
                    return Collections.emptyList();
                }
             */
            def methodName = propStack.subList(0, propStack.size()).collect { data.upperCamelCase.call(it.name) }.join('') // e.g. AddressPersonsContact
            int maxCheckProp = propIsCollectionStack.last() ? propIsCollectionStack.indexOf(Boolean.TRUE) : propStack.size() // The index of the first entry of propIsCollectionStack indicating value collection
            def checkName = propStack.subList(0, maxCheckProp).collect { data.upperCamelCase.call(it.name) }.join('') // e.g. AddressPersons

            // iterate through propStack and propIsArrayStack
            // Before first array type is encountered, add getter calls
            // When first array type is encountered, add .stream() and switch mode to .map(...)
            // Whenever another array type is encountered, use .flatMap(...) instead of .map(...)
            List parts = []
            boolean useGetter = true
            for (int i = 0; i < propStack.size(); i++) {
                def currUpper = data.upperCamelCase.call(propStack[i].name)
                if (useGetter) {
                    // getXXX()
                    parts.add("get${currUpper}()")
                } else {
                    // TODO Teach Eiko and Stephan
                    def parentProp = propStack[i-1].name.take(1)
                    if (propIsArrayStack[i]) {
                        // flatMap(), e.g. flatMap(contact -> contact.getEmail().stream())
                        parts.add("filter(${parentProp} -> ${parentProp}.get${currUpper}() != null)")
                        parts.add("flatMap(${parentProp} -> ${parentProp}.get${currUpper}().stream())")
                    } else {
                        // map(), e.g. map(person -> person.getContact())
                        parts.add("filter(${parentProp} -> ${parentProp}.get${currUpper}() != null)")
                        parts.add("map(${parentProp} -> ${parentProp}.get${currUpper}())")
                    }
                }
                if (useGetter && propIsArrayStack[i]) {
                    parts.add("stream()")
                    useGetter = false
                }
            }
            parts.add('collect(Collectors.toList())')

            // If the very last entry is the first array type, then these is no need to appending
            // .stream() and .collect(Collectors.toList()) -> just discard these two entries!
            if (parts[parts.size()-2] == "stream()") {
                parts = parts.subList(0, parts.size() - 2)
            }
            def retType = data.upperCamelCase.call(type.name)
            def stream = parts[0] + parts.subList(1,parts.size()).collect {"\n                    .$it"}.join('')
            def output = """
    public static List<${retType}> get${methodName}(${targetType} target) {
        if (check${checkName}Exists(target)) {
            return target.${stream};
        }
        return Collections.emptyList();
    }"""
            println output
        }

//        type.properties.findAll { prop -> return prop.isRefTypeOrComplexType() }.each { prop ->
        data.filterProps.call(type, [refComplex:true]).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            printGetForType.call(prop.type.type)
            popStacks.call()
        }
    }

    /**
     * Performs the actual code generation for one type
     * @param type The type, which ist to be processed
     * @param joined Indicates, whether that type is a joined type (contains a property of the type ObjectBase)
     */
    private void executeForType(Type type, boolean joined) {
        this.joined = joined
        targetType = data.upperCamelCase.call(type.name)
        currentType = type
        println '###################################################################'
        println "Start of $targetType:"
        println '###################################################################'

        /* 1st loop: find property names and mask keys */
        prepareStacks.call()

        /* 2nd loop: find property names affected by masking a mask key */
        prepareStacks.call()

        /* 3rd loop: find mapping of mask key to the number of deleted property occurrences triggered by actually masking that key. */
        prepareStacks.call()

        Type tunedType = data.copyType.call(currentType)
        tuneType.call(tunedType)

        // find keys for method removeXXX(pojo, UUID) -> find array of ref or complex properties
        List<String> removeKeys = evalRemoveKeysForType.call(tunedType)
        println "type=${currentType.name} removeKeys=${removeKeys}"

        // start printing class content
        String fileHead = """
/*********start*********/
package de.lisaplus.lisa.junction.model.handling;

/**
 * This file is generated by jsonCodeGen. Changes will be overwritten with next code generation run.
 * Template: handling.txt
 */

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import de.lisaplus.lisa.junction.model.*;

/**
 * This class contains the Unit test for masking of class $targetType. 
 */
public class ${targetType}Handling {
"""

        println fileHead

        println """
    /**
     * For restoring of array properties with entryId attributes these entryId values need to match.
     * This method assumes that array dimension of objects <i>source</i> and <i>target</i> match!
     * @param source The object, which defines the entryId values
     * @param target The object, which is to inherit the entryId values.
     */
    public static void ensureMatchingEntryId(final ${targetType} source, final ${targetType} target) {"""
        allLines.clear()
        prepareStacks.call()
        createEnsureMatchingForType.call(tunedType, allLines, 0)
        allLines.each { line -> println line }
        println """    }

    /**
     * Returns the value(s) associated with a mask key.
     * @param pojo The object to process
     * @param maskKey The mask key to process.
     * @return The value(s) associated with a mask key.
     */
    public static Object getValue(final ${targetType} pojo, final String maskKey) {
        switch(maskKey) {"""
        allLines.clear()
        prepareStacks.call()
        createGetValueForType.call(tunedType, allLines)
        allLines.each { line -> println line }
        println """
        default:
            throw new RuntimeException(String.format("Unsupported mask key '%s'!", maskKey));
        }
    }"""
        /* 5th loop: method checkXXXExists() */
        prepareStacks.call()
        printCheckExistsForType.call(tunedType)

        /* 6th loop: method getXXX() */
        prepareStacks.call()
        printGetForType.call(tunedType)


        for(String key : removeKeys) {
            println printRemoveForKey.call(key)
        }

        println '}\n'
    }   // end of executeForType

}
