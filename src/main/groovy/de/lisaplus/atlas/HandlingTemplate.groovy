package de.lisaplus.atlas

import de.lisaplus.atlas.builder.JsonSchemaBuilder
import de.lisaplus.atlas.codegen.GeneratorBase
import de.lisaplus.atlas.interf.IModelBuilder
import de.lisaplus.atlas.model.Model
import de.lisaplus.atlas.model.Property
import de.lisaplus.atlas.model.Type

class HandlingTemplate {

    static main(args) {

        // service service-junction
        def base = '/home/stefan/Entwicklung/service-junction/models/models-lisa-server/model/'
        def modelPath = args.length == 0 ?
                base + 'junction.json'
                // base + 'shared\\geo_point.json'
                : args[0]
        def typeName = args.length > 0 ?
                args[1]
                : 'Junction' // 'JunctionContact' // 'JunctionLocationStreetsItem' // 'JunctionContactJoined' // 'Junction' // 'JunctionJoined' // 'JunctionNumber'  // 'Contact_type' // 'JunctionLocation' // 'JunctionContact'

        /*
        // service service-op-message
        def base = '/home/stefan/Entwicklung/service-op-message/models/models-lisa-server/model/'
        def modelPath = args.length == 0 ?
                base + 'op_message.json'
                : args[0]
        def typeName = args.length > 0 ?
                args[1]
                : 'ObjectGroup' // 'OpMessage' // 'OpMessageJoined'
        */

        /*
        // service incident
        def base = '/home/stefan/Entwicklung/service-op-message/models/models-lisa-server/model/'
        def modelPath = args.length == 0 ?
                base + 'incident.json'
                : args[0]
        def typeName = args.length > 0 ?
                args[1]
                : 'Incident' // 'ObjectBase'
        */


        def template = new HandlingTemplate(modelPath)
        template.execute(typeName, typeName.endsWith('Joined'))

        // Check for exception while running code generation for all available types
        // template.generateAll()
    }

    /** The path to the model definition file */
    String modelPath = modelPath
    /** The complete model with all types */
    Model model
    /** The bindings of the template / code generation */
    Map data
    /** Indicates whether the current type is a joined type */
    boolean joined
    /** The name of the Java class, which is being masked. */
    String targetType
    /** This stack holds the property (names) visited while traversing the object hierarchy.*/
    List<Property> propStack = []
    /** Indicates that this property is an array. This sack is build while traversing the object hierarchy. */
    List<Boolean> propIsArrayStack = []
    /**
     *  Indicates that this property or any of its parents was an array and that we therefore have to process an collection.
     *  This sack is build while traversing the object hierarchy.
     */
    List<Boolean> propIsCollectionStack = []
    /**
     * Defines overwrites for maskKeys (mapping of property name to associated mask key).
     * This may be necessary for e.g. Joined types, where on property holds the Id of the joined object, and another
     * property holds the joined object itself (property objectBaseId vs. property objectBase).
     */
    Map<String, String> maskKeyOverwrites
    /** For caching the lines generated by the (recursive) closure calls of the model loops! */
    List<String> allLines = []
    /** For enabling/disabling debug output */
    boolean verbose = false

    HandlingTemplate(String modelPath) {
        this.modelPath = modelPath
        this.model = readModel(modelPath)
    }

    private Model readModel(String modelPath) {
        def modelFile = new File(modelPath)
        IModelBuilder builder = new JsonSchemaBuilder()
        return builder.buildModel(modelFile)
    }

    /**
     * Execute code generation for all types
     */
    void generateAll() {
        GeneratorBase generator = new DummyGenerator()
        // first process normal types
        this.model = readModel(modelPath)
        data = generator.createTemplateDataMap(model)
        def normalTypes = model.types.findAll { type -> !type.name.endsWith('Joined')}.collect()
        for (Type type : normalTypes) {
            executeForType(type, false)
        }
        // then reload model to erase effects of type tuning and process joined types
        this.model = readModel(modelPath)
        data = generator.createTemplateDataMap(model)
        def joinedTypes = model.types.findAll { type -> type.name.endsWith('Joined')}.collect()
        for (Type type : joinedTypes) {
            executeForType(type, true)
        }
    }

    /**
     * Execute code generation for one type
     * @param typeName The name of the type, which is to be processed
     * @param joined Indicates whether that type is a joined type
     */
    void execute(String typeName, boolean joined) {
        GeneratorBase generator = new DummyGenerator()
        data = generator.createTemplateDataMap(model)
        Type type = data.model.types.find {type -> type.name == typeName}
        executeForType(type, joined)
    }

    private void executeForType(Type type, boolean joined) {
        this.joined = joined
        targetType = data.upperCamelCase.call(type.name)
        maskKeyOverwrites = [:]
        boolean printDebug = true
        println '###################################################################'
        println "Start of $targetType:"
        println '###################################################################'

        /* 1st loop: find property names and mask keys */
        prepareStacks.call()
        // The names of the properties defined in the current type
        Set<String> propNames = []
        // The mask keys, which are available for the current type
        List<String> maskKeys = []

        /* 2nd loop: find property names affected by masking a mask key */
        prepareStacks.call()

        /* 3rd loop: find mapping of mask key to the number of deleted property occurrences triggered by actually masking that key. */
        prepareStacks.call()

        createUpdateMaskForType.call(type)

        // start printing class content
        String fileHead = """
/*********start*********/
package de.lisaplus.lisa.junction.model.handling;

/**
 * This file is generated by jsonCodeGen. Changes will be overwritten with next code generation run.
 * Template: handling.txt
 */

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import de.lisaplus.lisa.junction.model.*;

/**
 * This class contains the Unit test for masking of class $targetType. 
 */
public class ${targetType}Handling {
"""

        println fileHead

        println """
/*********snip**********/
    /**
     * For restoring of array properties with entryId attributes these entryId values need to match.
     * This method assumes that array dimension of objects <i>source</i> and <i>target</i> match!
     * @param source The object, which defines the entryId values
     * @param target The object, which is to inherit the entryId values.
     */
    private void ensureMatchingEntryId(final ${targetType} source, final ${targetType} target) {"""
        tuneType.call(type)
        allLines.clear()
        prepareStacks.call()
        createEnsureMatchingForType.call(type, allLines, 0)
        allLines.each { line -> println line }
        println """    }

    /**
     * Returns the value(s) associated with a mask key.
     * @param pojo The object to process
     * @param maskKey The mask key to process.
     * @return The value(s) associated with a mask key.
     */
    public static Object getValue(final ${targetType} pojo, final String maskKey) {
        switch(maskKey) {"""
        allLines.clear()
        prepareStacks.call()
        createGetValueForType.call(type, allLines)
        allLines.each { line -> println line }
        println """
        default:
            throw new RuntimeException(String.format("Unsupported mask key '%s'!", maskKey));
        }
    }"""
        /* 5th loop: method checkXXXExists() */
        prepareStacks.call()
        printCheckExistsForType.call(type)

        /* 6th loop: method getXXX() */
        prepareStacks.call()
        printGetForType.call(type)

        println '}\n'
    }

    /**
     * Prepares the stacks for running the next loop over the model
     */
    def prepareStacks = {
        propStack.clear()
        propIsArrayStack.clear()
        // avoid extra case for handling empty stack!
        propIsCollectionStack = [false]
    }

    /**
     * Adds new elements to the stacks
     * @param property The property, which is to be visited
     */
    def putStacks = { Property property ->
        propStack.add(property)
        propIsArrayStack.add(property.type.isArray)
        // If either already collection of if this property is an collection.
        propIsCollectionStack.add(propIsCollectionStack.last() || property.type.isArray)
    }

    /**
     * Pops the latest elements from the stacks
     */
    def popStacks = {
        propStack.pop()
        propIsArrayStack.pop()
        propIsCollectionStack.pop()
    }

    /**
     * <b>THIS METHOD ALTERS THE MODEL!!!</b>
     * This method tunes the properties of a (complex or reference) type and calls itself recursively if the type
     * itself holds properties of other (complex or reference) types.
     * Checks for properties with the tag <i>prepLookup</i> and
     * <ul>
     * <li>joined==true: removes the property completely</li>
     * <li>joined==false: removes the suffix Id</li>
     * @param type The type to process.
     */
    def tuneType = { Type type ->
        Closure<Void> action
        if (joined) {
            action = { Property prop ->
                println "// ATTENTION: Removing lookup property ${prop.name}"
                type.properties.remove(prop)
            }
        } else {
            action = { Property prop ->
                def orig = prop.name
                def shorten = prop.name.take(prop.name.length() - 2)
                println "// ATTENTION: Renaming lookup property from $orig to $shorten"
                prop.setName(shorten)
            }
        }
        Collection<Property> lookupProps = type.properties.findAll { Property prop -> prop.hasTag('prepLookup') && prop.name.endsWith('Id') }
        type.properties.findAll { Property prop -> prop.implicitRefIsRefType()   } each { Property prop -> tuneType.call(prop.implicitRef.type) }
        type.properties.findAll { Property prop -> prop.isRefTypeOrComplexType() } each { Property prop -> tuneType.call(prop.type.type) }
        lookupProps.each(action)
    }

    /**
     * Actually creates the case of the getValue method for properties of a complex or reference class.
     * @param prop The property to process
     * @param lines Where the created lines of code are to be added.
     */
    def createGetValueSimple = { Property property, List<String> lines ->
        def parentCollection = propIsCollectionStack.last()
        def parentProp = propStack.empty ? null : propStack.last()
        def propStackParent = []; propStackParent.addAll(propStack)
        putStacks.call(property)
        def key = propStack.collect {prop -> prop.name}.join('.')
        if (verbose)  println "key=${key} parentCollection=${parentCollection} parCollClass=${parentCollection.class.getName()}"
        if (propStack.size() == 1) {
            // in case of normal type and tag 'prepLookup' add suffix Id to method name -> getObjectBaseId()!
            def suffix = !joined && property.hasTag('prepLookup') ? 'Id' : ''
            lines.add("""        case "${key}":
            return pojo.get${data.firstUpperCase.call(property.name)}${suffix}();""" )
        } else if (parentCollection) {
            // parent is collection: stream collection, map to value, collect(Collectors.toList())
            /* Example
                case "objectBase.gis.area.points.lon":
                    return getObjectBaseGisAreaPoints(target).stream().map(p -> p.getLon()).collect(Collectors.toList());
             */
            String methodName = propStackParent.collect{ prop -> data.upperCamelCase.call(prop.name) }.join('')
            String parentChar = parentProp.name.take(1)
            lines.add("""        case "${key}":
            return get${methodName}(pojo).stream().map(${parentChar} -> ${parentChar}.get${data.upperCamelCase.call(property.name)}()).collect(Collectors.toList());""")
            // lines.add("""        case "${propStack.collect {prop -> prop.name}.join('.')}": return null; // TODO""" )
        } else {
            // parent not a collection: simple parent null check and return value
            /* Example:
                case "objectBase.gis.area.projection":
                    if (checkObjectBaseGisAreaExists(pojo)) {
                        return pojo.getObjectBase().getGis().getArea().getProjection();
                    } else {
                        return null;
                    }
             */
            String methodName = propStackParent.collect{ prop -> data.upperCamelCase.call(prop.name) }.join('')
            String getChain = propStack.collect{ prop -> data.upperCamelCase.call(prop.name) }.join('().get')

            lines.add("""        case "${key}":
            if (check${methodName}Exists(pojo)) {
                return pojo.get${getChain}();
            } else {
                return null;
            }""" )
        }
        popStacks.call()
    }

    def createUpdateMaskForType = { Type type ->
        def parentType = data.upperCamelCase(type.name)
        List all = data.filterProps.call(type, [withoutTag:'notDisplayed'])
        List mask = []
        List alter = []
        List delete = []
        if (all.size() < 2) {
            throw new IllegalArgumentException('Need some properties!')
        } else {
            for(int idx = 0; idx<all.size(); idx++) {
                switch(idx%3) {
                    case 0:
                        mask += all[idx]
                        break
                    case 1:
                        alter += all[idx]
                        break
                    case 2:
                        delete += all[idx]
                        break
                }
            }
            println "mask=${mask.collect { it.name } } alter=${alter.collect { it.name} } delete=${delete.collect { it.name } } "
            // save state before

            println """
        // Collect three lists of property names:
        // List M: Property names got into mask. Assign altered values to DAOs (use alterValue(Object) and / or random.nextObject())
        //         The changed values are not to be picked up / written to storage
        // List A: Alter the values (use alterValue(Object) and / or random.nextObject())
        //         The changed values are to be persisted / written to storage
        // List D: Delete the values (setXXX(null))
        //         The values are to be deleted from the storage

        // Not recursive, just process the current type.
        // Discard properties with tag notToDispaly, divide remaining properties into
        // List M and A (n=2) or Lists M,A and D (n>=3)
        try {
            Dao${parentType} before = createInstance()

            // save state before"""
            for(Property prop : mask) {
                def name = data.upperCamelCase.call(prop.name)
                println "            def value${name}Before = before.get${name}()"
            }

            // create mask
            println """
            // request masking
            def mask = new PojoMask([${ mask.collect{ "'$it.name'"}.join(", ") }])
            de.lisaplus.lisa.junction.mask.Mask${parentType}.mask(before, mask)
            
            // setting altered values to masked field(s), to be ignored!"""
            for (Property prop : mask) {
                def name = data.upperCamelCase.call(prop.name)
                if (prop.isRefTypeOrComplexType()) {
                    def clazz = data.upperCamelCase.call(prop.type.type.name)
                    println "            before.set$name(random.nextObject(${clazz}, 'tenantId', 'daoContext'))"
                } else {
                    println "            before.set$name(alterValue(value${name}Before))"
                }
            }
            println """
            // These changed values are to be persisted / written to storage"""
            for (Property prop : alter) {
                def name = data.upperCamelCase.call(prop.name)
                if (prop.isRefTypeOrComplexType()) {
                    def clazz = data.upperCamelCase.call(prop.type.type.name)
                    println """            def value${name}Altered = random.nextObject(${clazz}, 'tenantId', 'daoContext')" +
            before.set$name(value${name}Altered)"""
                } else {
                    println """            def value${name}Altered = alterValue(before.get$name())
            before.set$name(value${name}Altered)"""
                }
            }

            println """
            // These values are to be deleted from the storage"""
            for (Property prop : delete) {
                def name = data.upperCamelCase.call(prop.name)
                println "            before.set$name(null)"
            }

            println """
            maskService.registerMask(${parentType}.class, mask)
            Dao${parentType}.restoreMasked(before, testContext, true)

            // get new state from storage back-end
            ${parentType} after = Dao${parentType}.byId(before.getGuid(), before.getDaoContext())

            // check that changed state of masked fields were not persisted in storage"""
            for (Property prop : mask) {
                def name = data.upperCamelCase.call(prop.name)
                println "            assertEquals(value${name}Before, after.${prop.name})"
            }
            println """
            // check that altered values were actually changed in the storage"""
            for (Property prop : alter) {
                def name = data.upperCamelCase.call(prop.name)
                println "            assertEquals(value${name}Altered, after.${prop.name})"
            }

            println """
            // check that deleted values were actually removed from the storage"""
            for (Property prop : delete) {
                println "            assertNull(after.${prop.name})"
            }

            println """
        } finally {
            maskService.clearMasks()
        }"""
        }
    }

    /**
     * Creates the case statements of the getValue method for a certain type, calls itself recursively for reference
     * and complex types!
     * @param type The type to process
     * @param lines Where the created lines of code are to be added.
     */
    def createGetValueForType = { Type type, List<String> lines ->
        data.filterProps.call(type, [refComplex:false, withoutTag:'notDisplayed']).each { Property prop ->
            if (verbose)  println "// createGetValueForType/RefTypeOrComplexType=false: type=${type.name} prop=${prop.name}"
            createGetValueSimple.call(prop, lines)
        }
        data.filterProps.call(type, [refComplex:true, withoutTag:'notDisplayed']).each { Property prop ->
            createGetValueSimple.call(prop, lines)
            // recursive call!
            putStacks.call(prop)
            createGetValueForType.call(prop.type.type, lines)
            popStacks.call()
        }
    }

    /**
     * Creates the content of the method ensureMatchingEntryId for a certain type, calls itself recursively for reference
     * and complex types!
     * @param type The type to process
     * @param lines Where the created lines of code are to be added.
     */
    Closure<Integer> createEnsureMatchingForType = { Type type, List<String> lines, int idx ->
        // Track the number of increments of idx!
        int incCount = 0
        if (propIsCollectionStack.last()) {
            Property pProp = propStack.last()
            boolean parentHasEntryId = pProp.isRefTypeOrComplexType() && pProp.type.type.properties.collect { prop2 -> prop2.name }.contains('entryId')
            if (parentHasEntryId) {
                /* Example
                final Iterator<AddressPerson> sourceIter1 = getAddressPersons(source).iterator();
                final Iterator<AddressPerson> targetIter1 = getAddressPersons(target).iterator();
                while(sourceIter1.hasNext()) {
                    targetIter1.next().setEntryId(sourceIter1.next().getEntryId());
                }
                */
                lines.add("        // found pProp=${pProp.name} type=${data.upperCamelCase.call(type.name)}")
                def jType = data.upperCamelCase.call(type.name)
                def methodName = propStack.collect { prop -> data.upperCamelCase.call(prop.name) }.join('')
                idx += 1
                incCount += 1
                lines.add(
                        """        final Iterator<${jType}> sourceIter${idx} = get${methodName}(source).iterator();
        final Iterator<${jType}> targetIter${idx} = get${methodName}(target).iterator();
        while(sourceIter${idx}.hasNext()) {
            targetIter${idx}.next().setEntryId(sourceIter1.next().getEntryId());
        }""")

            }
        }
        data.filterProps.call(type, [refComplex:true]).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            // idx may have been incremented 0 to n times by the recursive call!
            int recIncCount = createEnsureMatchingForType.call(prop.type.type, lines, idx)
            popStacks.call()
            idx += recIncCount
            incCount += recIncCount
        }
        return incCount
    }

    /**
     * Prints the methods checkXXX(target) for a certain type, calls itself recursively for reference and complex types!
     * @param type The type to process
     */
    def printCheckExistsForType = { Type type ->
        int size = propIsCollectionStack.size()
        if ( size > 2 && propIsCollectionStack.get(size-2)) {
            // can not check for null in children of array property -> stop creating more methods checkXXXExists()!
            return
        }
        if (!propStack.isEmpty()) {
            /*
                public static boolean checkObjectBaseGisArea(JunctionNumberJoined target) {
                    return target.getObjectBase() != null
                            && target.getObjectBase().getGis() != null
                            && target.getObjectBase().getGis().getArea() != null;
                }
             */
            def checkMethodPart = propStack.collect{ data.upperCamelCase.call(it.name) }.join('')       // e.g. AddressPersonsContact
            // create longest getter call chain and then process it from one to all elements.
            List lines = []
            List getCalls = propStack.collect { "get${data.upperCamelCase.call(it.name)}()"}
            for (int i = 0; i < getCalls.size(); i++) {
                def cond = getCalls.subList(0, i+1).join('.')
                lines.add("target.${cond} != null")
            }
            def conditions = lines.join('\n                && ')
            def output = "\n    public static boolean check${checkMethodPart}Exists(${targetType} target) {\n        return ${conditions};\n    }"
            println output
        }

//        type.properties.findAll { prop -> return prop.isRefTypeOrComplexType() }.each { prop ->
        data.filterProps.call(type, [refComplex:true]).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            printCheckExistsForType.call(prop.type.type)
            popStacks.call()
        }
    }

    /**
     * Prints the methods checkXXX(target) for a certain type, calls itself recursively for reference and complex types!
     * @param type The type to process
     */
    def printGetForType = { Type type ->
        if (propIsCollectionStack.last()) {
            // Example for key address.persons.contact where persons is the only array type
            // In case of multiple array types use .flatMap() for 2. to last array type!
            // We can not check for null references for objects in the object tree after hitting the first array property.
            // ->
            // A: the method checkXXXExists only checks for null references up to the first array property.
            // B: do use Stream.filter() with a predicate for filtering out the null references!
            /*
                private static List<ContactData> getAddressPersonsContact(JunctionContactJoined target) {
                    if (checkAddressPersonsExists(target)) {
                        return target.getAddress().getPersons().stream()
                                                               .filter(p -> p.getContact() != null)
                                                               .map(p -> p.getContact())
                                                               .collect(Collectors.toList());
                    }
                    return Collections.emptyList();
                }
             */
            def methodName = propStack.subList(0, propStack.size()).collect { data.upperCamelCase.call(it.name) }.join('') // e.g. AddressPersonsContact
            int maxCheckProp = propIsCollectionStack.last() ? propIsCollectionStack.indexOf(Boolean.TRUE) : propStack.size() // The index of the first entry of propIsCollectionStack indicating value collection
            def checkName = propStack.subList(0, maxCheckProp).collect { data.upperCamelCase.call(it.name) }.join('') // e.g. AddressPersons

            // iterate through propStack and propIsArrayStack
            // Before first array type is encountered, add getter calls
            // When first array type is encountered, add .stream() and switch mode to .map(...)
            // Whenever another array type is encountered, use .flatMap(...) instead of .map(...)
            List parts = []
            boolean useGetter = true
            for (int i = 0; i < propStack.size(); i++) {
                def currUpper = data.upperCamelCase.call(propStack[i].name)
                if (useGetter) {
                    // getXXX()
                    parts.add("get${currUpper}()")
                } else {
                    // TODO Teach Eiko and Stephan
                    def parentProp = propStack[i-1].name.take(1)
                    if (propIsArrayStack[i]) {
                        // flatMap(), e.g. flatMap(contact -> contact.getEmail().stream())
                        parts.add("filter(${parentProp} -> ${parentProp}.get${currUpper}() != null)")
                        parts.add("flatMap(${parentProp} -> ${parentProp}.get${currUpper}().stream())")
                    } else {
                        // map(), e.g. map(person -> person.getContact())
                        parts.add("filter(${parentProp} -> ${parentProp}.get${currUpper}() != null)")
                        parts.add("map(${parentProp} -> ${parentProp}.get${currUpper}())")
                    }
                }
                if (useGetter && propIsArrayStack[i]) {
                    parts.add("stream()")
                    useGetter = false
                }
            }
            parts.add('collect(Collectors.toList())')

            // If the very last entry is the first array type, then these is no need to appending
            // .stream() and .collect(Collectors.toList()) -> just discard these two entries!
            if (parts[parts.size()-2] == "stream()") {
                parts = parts.subList(0, parts.size() - 2)
            }
            def retType = data.upperCamelCase.call(type.name)
            def stream = parts[0] + parts.subList(1,parts.size()).collect {"\n                    .$it"}.join('')
            def output = """
    private static List<${retType}> get${methodName}(${targetType} target) {
        if (check${checkName}Exists(target)) {
            return target.${stream};
        }
        return Collections.emptyList();
    }"""
            println output
        }

//        type.properties.findAll { prop -> return prop.isRefTypeOrComplexType() }.each { prop ->
        data.filterProps.call(type, [refComplex:true]).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            printGetForType.call(prop.type.type)
            popStacks.call()
        }
    }
}
