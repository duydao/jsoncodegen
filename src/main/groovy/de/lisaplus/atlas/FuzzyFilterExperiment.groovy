package de.lisaplus.atlas

import de.lisaplus.atlas.builder.JsonSchemaBuilder
import de.lisaplus.atlas.codegen.GeneratorBase
import de.lisaplus.atlas.interf.IModelBuilder
import de.lisaplus.atlas.model.Model
import de.lisaplus.atlas.model.Property
import de.lisaplus.atlas.model.StringType
import de.lisaplus.atlas.model.Type

class FuzzyFilterExperiment {

    static main(args) {

        def base = '/home/stefan/Entwicklung/service-op-message/models/models-lisa-server/model/'
        def modelPath = args.length == 0 ?
                base + 'op_message.json'
                : args[0]
        def typeName = args.length > 0 ?
                args[1]
                : 'OpMessageJoined' // 'OpMessage' // 'OpMessageJoined'

        def fuzzyExp = new FuzzyFilterExperiment(modelPath)
        fuzzyExp.execute(typeName, typeName.endsWith('Joined'))

        // Check for exception while running code generation for all available types
         // fuzzyExp.generateAll()
    }

    /** The path to the model definition file */
    String modelPath = modelPath
    /** The complete model with all types */
    Model model
    /** The bindings of the template / code generation */
    Map data
    /** Indicates whether the current type is a joined type */
    boolean joined
    /** The name of the Java class, which is being processed. */
    String targetType
    /** The name of the Java class, which is being processed, without suffix 'Joined'! */
    String targetTypeNotJoined
    /** This stack holds the property (names) visited while traversing the object hierarchy.*/
    List<Property> propStack = []
    /** Indicates that this property is an array. This sack is build while traversing the object hierarchy. */
    List<Boolean> propIsArrayStack = []
    /** The name of the Java class, which holds the property. This sack is build while traversing the object hierarchy. */
    List<String> parentJavaClass = []
    /**
     *  Indicates that this property or any of its parents was an array and that we therefore have to process an collection.
     *  This sack is build while traversing the object hierarchy.
     */
    List<Boolean> propIsCollectionStack = []
    /** For caching the lines generated by the (recursive) closure calls of the model loops! */
    List<String> allLines = []
    /** For enabling/disabling debug output */
    boolean verbose = false

    // Closures, which will end up at the start of the templates!
    /**
     * Prepares the stacks for running the next loop over the model
     */
    def prepareStacks = {
        propStack.clear()
        propIsArrayStack.clear()
        // avoid extra case for handling empty stack!
        propIsCollectionStack = [false]
        parentJavaClass.clear()
    }

    /**
     * Adds new elements to the stacks
     * @param property The property, which is to be visited
     */
    def putStacks = { Property property ->
        if (propStack.empty) {
            parentJavaClass.add(targetType)
        } else {
            if (verbose) {
                def pClassName = propStack.last().type.type.name;
                println "// prop=${property.name} parentClas=${pClassName}"
            }
            parentJavaClass.add(data.upperCamelCase.call(propStack.last().type.type.name))
        }
        propStack.add(property)
        propIsArrayStack.add(property.type.isArray)
        // If either already collection of if this property is an collection.
        propIsCollectionStack.add(propIsCollectionStack.last() || property.type.isArray)
    }

    /**
     * Pops the latest elements from the stacks
     */
    def popStacks = {
        propStack.pop()
        propIsArrayStack.pop()
        propIsCollectionStack.pop()
        parentJavaClass.pop()
    }

    // findStringProps calls itself, needs forward declaration in template!
    /**
     * Finds the relevant String properties of the current type, calls itself for complex inner types!
     */
    def findStringProps = { Type type, List<String> lines ->
        // loop over string properties (not array!)
        type.properties.findAll { prop -> prop.type instanceof StringType && ! prop.type.isArray } .each { prop ->
            propStack.add(prop)
            if (verbose) {
                def key = propStack.collect { prop2 -> prop2.name }.join('.')
                println "    // name=${prop.name} key=$key type=${prop.type.class.getSimpleName()} isArray=${prop.type.isArray}"
            }
            propStack.pop()
            createFuzzyTest(prop, lines)
        }

        // no recursive calls for now!
        data.filterProps.call(type, [refComplex:true, array:false, withoutTag:'notDisplayed']).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            findStringProps.call(prop.type.type, lines)
            popStacks.call()
        }
    }

    /**
     * Appends lines of a test method for a relevant String property to parameter lines!
     */
    def createFuzzyTest = { Property property, List<String> lines ->
        def prefix = '\n                        '
        def mapLines = ''
        def mapLinesNotJoined = ''
        def propParentClass
        if (propStack.isEmpty()) {
            propParentClass = targetTypeNotJoined
        } else {
            propParentClass = data.upperCamelCase.call(propStack.last().type.typeName)
        }
        putStacks.call(property)
        def key = propStack.collect {prop -> prop.name}.join('.')
        def lowerProp = data.lowerCamelCase.call(property.name)
        if (key.startsWith('objectBase.')) {
            // special case for string properties attached to inner ObjectBase!
            def propIter = propStack.iterator()
            def classIter = parentJavaClass.iterator()
            def firstProp = propIter.next()
            def firstClass = classIter.next()
            assert firstProp.name == 'objectBase' && firstClass == targetType : "firstProp=${firstProp.name}, targetType=${targetType}"
            assert targetType.endsWith('Joined') : targetType
            // get corresponding XXXJoined object to be able to collect the string values residing in the ObjectBase!
            mapLinesNotJoined += "${prefix}.map(dao -> Dao${targetType}.byId(dao.getGuid(), testContext))"
            mapLinesNotJoined += "${prefix}.map(${targetType}::getObjectBase)"
            mapLines += "${prefix}.map(${firstClass}::getObjectBase)"
            while (propIter.hasNext()) {
                def clazz = classIter.next()
                def clazzNotJoined = clazz.endsWith("Joined") ? clazz[0..-7] : clazz
                def getter = '::get' + data.upperCamelCase.call(propIter.next().name)
                mapLines += "${prefix}.map(${clazz}${getter})"
                mapLinesNotJoined += "${prefix}.map(${clazzNotJoined}${getter})"
            }
        } else {
            def propIter = propStack.iterator()
            def classIter = parentJavaClass.iterator()
            while (propIter.hasNext()) {
                def clazz = classIter.next()
                def clazzNotJoined = clazz.endsWith("Joined") ? clazz[0..-7] : clazz
                def getter = '::get' + data.upperCamelCase.call(propIter.next().name)
                mapLines += "${prefix}.map(${clazz}${getter})"
                mapLinesNotJoined += "${prefix}.map(${clazzNotJoined}${getter})"
            }
        }

        if (verbose) {
            println "/* mapLines=$mapLines */"
        }
        // ensure unique method names
        def methodName = propStack.collect {prop -> data.upperCamelCase.call(prop.name)}.join('')
        lines.add("""
    @Test
    public void testSearch${methodName}() {
        final List<Dao${targetTypeNotJoined}> daos =  createInsertDaos("${lowerProp}", String.class, ${propParentClass}.class);
        final List<String> actValues1 = daos.stream()${mapLinesNotJoined}
                        .collect(Collectors.toList());
        assertEquals(values.length, actValues1.size());
        assertTrue(actValues1.toString(), actValues1.containsAll(Arrays.asList(values)));

        try {
            final String sort = null;
            final String key = "$key";
            textPatter2Matches.entrySet().forEach( entry -> {
                final String pattern = entry.getKey();
                final List<String> expValues = entry.getValue();
                final String filter = String.format(" { \\"%s\\" : { \\"text\\": \\"%s\\"}}", key, pattern);
                final List<String> actValues = Dao${targetType}.list(testContext, 0, 0, filter, sort)
                        .stream()${mapLines}
                        .collect(Collectors.toList());
                assertEquals(String.format("%s: %s", pattern, actValues), expValues.size(), actValues.size());
                assertTrue(String.format("%s: %s", pattern, actValues), actValues.containsAll(expValues));
            });
            regexPatter2Matches.entrySet().forEach( entry -> {
                final String pattern = entry.getKey();
                final List<String> expValues = entry.getValue();
                final String filter = String.format(" { \\"%s\\" : { \\"regex\\": \\"%s\\"}}", key, pattern);
                final List<String>  actValues = Dao${targetType}.list(testContext, 0, 0, filter, sort)
                        .stream()${mapLines}
                        .collect(Collectors.toList());
                assertEquals(String.format("%s: %s", pattern, actValues), expValues.size(), actValues.size());
                assertTrue(String.format("%s: %s", pattern, actValues), actValues.containsAll(expValues));
            });
        } finally {
            // clean up to avoid interfering with other tests!
            for (Dao${targetTypeNotJoined} dao : daos) {
                dao.delete();
            }
        }
    }""")
        popStacks.call()
    }

    // constructor and methods.
    FuzzyFilterExperiment(modelPath) {
        this.modelPath = modelPath
        this.model = readModel(modelPath)
    }

    private Model readModel(String modelPath) {
        def modelFile = new File(modelPath)
        IModelBuilder builder = new JsonSchemaBuilder()
        return builder.buildModel(modelFile)
    }

    /**
     * Execute code generation for all types
     */
    void generateAll() {
        GeneratorBase generator = new DummyGenerator()
        /*
        data = generator.createTemplateDataMap(model)
        for(Type type : model.types) {
            executeForType(type, type.name.endsWith('Joined'))
        }
        */

        // first process normal types
        this.model = readModel(modelPath)
        data = generator.createTemplateDataMap(model)
        def normalTypes = model.types.findAll { type -> !type.name.endsWith('Joined')}.collect()
        for (Type type : normalTypes) {
            executeForType(type, false)
        }
        // then reload model to erase effects of type tuning and process joined types
        this.model = readModel(modelPath)
        data = generator.createTemplateDataMap(model)
        def joinedTypes = model.types.findAll { type -> type.name.endsWith('Joined')}.collect()
        for (Type type : joinedTypes) {
            executeForType(type, true)
        }
    }


    /**
     * Execute code generation for one type
     * @param typeName The name of the type, which is to be processed
     * @param joined Indicates whether that type is a joined type
     */
    void execute(String typeName, boolean joined) {
        GeneratorBase generator = new DummyGenerator()
        data = generator.createTemplateDataMap(model)
        Type type = data.model.types.find {type -> type.name == typeName}
        executeForType(type, joined)
    }

    private void executeForType(Type type, boolean joined) {
        this.joined = joined
        targetType = data.upperCamelCase.call(type.name)
        println '###################################################################'
        println "Start of $targetType:"
        println '###################################################################'


        def extraParam = ['serviceBase' : 'opMessage']

        def daoImport = "import de.lisaplus.lisa.${extraParam.serviceBase}.dao.*;"
        if (joined) {
            daoImport += "\nimport de.lisaplus.lisa.${extraParam.serviceBase}.dao.joined.*;"
        }
        targetTypeNotJoined = targetType.endsWith("Joined") ? targetType.replace('Joined', '') : targetType

        String fileHead = """
/*********start*********/
package de.lisaplus.lisa.${extraParam.serviceBase}.fuzzy;

/**
 * This file is generated by jsonCodeGen. Changes will be overwritten with next code generation run.
 * Template: test_fuzzy.txt
 */

import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import com.swarco.cip.utils.config.ConfigFactory;
import com.swarco.cip.utils.config.LiveConfig;
import com.swarco.cip.utils.config.impl.PureVarConfig;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import de.lisaplus.FixedValuesRandomizer;
$daoImport
import de.lisaplus.lisa.${extraParam.serviceBase}.model.*;
import de.lisaplus.util.dao.DaoContext;
import de.lisaplus.util.mask.MockPojoMaskService;
import de.lisaplus.util.mongodb.DbFactory;
import io.github.benas.randombeans.EnhancedRandomBuilder;
import io.github.benas.randombeans.FieldDefinitionBuilder;
import io.github.benas.randombeans.api.EnhancedRandom;
import io.github.benas.randombeans.api.Randomizer;
import io.github.benas.randombeans.randomizers.range.LocalDateTimeRangeRandomizer;

/**
 * Integration test for fuzzy search in class Dao$targetType.
 */
public class IT_Fuyyz_Search_Dao_$targetType {
    
    /** The values to use for the bean properties when generation beans with random beans. */
    private static final String[] values;
    /** Add mapping of text pattern to expected matches. Text query are case insensitive! */
    private static Map<String, List<String>> textPatter2Matches;
    /** Add mapping of regex pattern to expected matches. Regex query are case sensitive! */
    private static Map<String, List<String>>  regexPatter2Matches;
    /** DaoContext to use for this test. */
    static DaoContext testContext;
    /** PojoMaskService embedded into #testContext */
    static MockPojoMaskService maskService;

    static {
        values = new String[] { "aber", "Berlin", "Erlangen", "Jena", "Hans", "Mike", " 123456 ", " der hat Leerzeichen ", "", "   ", " Erhard", " niedErmitderIder ",
                null, "EndeAufen", "erStartLow", " soleCaseOfeRyay", " soleCaseOfERyay "};

        textPatter2Matches = new HashMap<>();
        // case insensitive!
        textPatter2Matches.put("er", Arrays.asList("aber", "Berlin", "Erlangen", " der hat Leerzeichen ", " Erhard", " niedErmitderIder ", "erStartLow", " soleCaseOfeRyay", " soleCaseOfERyay "));
        textPatter2Matches.put("Er", Arrays.asList("aber", "Berlin", "Erlangen", " der hat Leerzeichen ", " Erhard", " niedErmitderIder ", "erStartLow", " soleCaseOfeRyay", " soleCaseOfERyay "));
        textPatter2Matches.put("eR", Arrays.asList("aber", "Berlin", "Erlangen", " der hat Leerzeichen ", " Erhard", " niedErmitderIder ", "erStartLow", " soleCaseOfeRyay", " soleCaseOfERyay "));
        textPatter2Matches.put("ER", Arrays.asList("aber", "Berlin", "Erlangen", " der hat Leerzeichen ", " Erhard", " niedErmitderIder ", "erStartLow", " soleCaseOfeRyay", " soleCaseOfERyay "));

        // see e.g. https://stackoverflow.com/questions/3305561/how-to-query-mongodb-with-like
        regexPatter2Matches = new HashMap<>();
        // starts with upper case
        regexPatter2Matches.put("^Er.*", Arrays.asList("Erlangen"));
        // ends with
        regexPatter2Matches.put(".*en\044", Arrays.asList("Erlangen", "EndeAufen"));
        // lower case anywhere
        regexPatter2Matches.put(".*er.*", Arrays.asList("aber", "Berlin", " der hat Leerzeichen ", " niedErmitderIder ", "erStartLow"));
        // Upper case anywhere
        regexPatter2Matches.put(".*Er.*", Arrays.asList("Erlangen", " Erhard", " niedErmitderIder "));
        // Case not present!
        regexPatter2Matches.put("eR", Arrays.asList(" soleCaseOfeRyay"));
        // Case not present!
        regexPatter2Matches.put("ER", Arrays.asList(" soleCaseOfERyay "));
    }

    @BeforeClass
    public static void before() {
        System.out.println("*********************** IT_Fuyyz_Search_Dao_$targetType - Start ***********************");
        LiveConfig liveConfig = ConfigFactory.getInst().getConfig();
        if (liveConfig==null) {
            System.out.println("set new LiveConfig instance");
            liveConfig = new PureVarConfig();
            ConfigFactory.getInst().setConfig(liveConfig);
            if (System.getenv("MONGODB_ADDRESS")==null)
                System.setProperty("MONGODB_ADDRESS","localhost");
            if (System.getenv("MONGODB_PORT")==null)
                System.setProperty("MONGODB_PORT","30001");
            DbFactory.getInst().reinit();
        }

        final String tenantId = String.format("test_tenant_%s", UUID.randomUUID().toString());
        testContext = new DaoContext(tenantId, "Junit-Test");
        maskService = new MockPojoMaskService();
        testContext.setMaskService(maskService);
    }

    @AfterClass
    public static void after() {
        System.out.println("*********************** IT_Fuyyz_Search_Dao_$targetType - End ***********************");
    }

    /**
     * Creates a collection of Dao instances and adds them to the storage back-end.
     * The Values associated with one attribute of the object will be forced to represent the {@link #values}.
     * @param propName The name of the property
     * @param propClass The type of the property
     * @param beanClass The class, where the property is actually defined (so usually not the Dao subtype!)
     * @return The new Dao instances
     */
    private List<Dao$targetTypeNotJoined> createInsertDaos(String propName, Class<?> propClass, Class<?> beanClass) {
        final EnhancedRandom random = getEnhancedRandom(propName, propClass, beanClass);
        return IntStream.range(0, values.length)
                        .mapToObj(i -> createInstance(random))
                        .collect(Collectors.toList());
    }

    /**
     * Creates a new Dao instance and adds it to the storage back-end.
     * @param random The object to use for generating objects.
     * @return The new Dao instance
     */
    private Dao$targetTypeNotJoined createInstance(EnhancedRandom random) {
        DaoObjectBase objectBase = random.nextObject(DaoObjectBase.class);
        objectBase.setDaoContext(testContext);
        // When EnhancedRandom starts creating fraction of seconds, then all DateTimeType properties must be processed!
        // objectBase.setXXX(toStartOfSecond(objectBase.getXXX()))
        objectBase.insert();

        // currently tenantId only gets overwritten in setDaoContext(DaoContext) when it is still null!
        Dao$targetTypeNotJoined dao = random.nextObject(Dao${targetTypeNotJoined}.class);
        dao.setDaoContext(testContext);
        // When EnhancedRandom starts creating fraction of seconds, then all DateTimeType properties must be processed!
        // x.setCreated(toStartOfSecond(x.getCreated()))
        dao.setObjectBaseId(objectBase.getGuid());
        dao.insert();

        return dao;
    }

    /**
     * An {@link EnhancedRandom} object for creating test objects. The Values associated with one attribute of the
     * object will be forced to represent the {@link #values}.
     * @param propName The name of the property
     * @param propClass The type of the property
     * @param beanClass The class, where the property is actually defined (so usually not the subtype DaoXXX!)
     * @return An {@link EnhancedRandom} object for creating test objects.
     */
    private EnhancedRandom getEnhancedRandom(String propName, Class<?> propClass, Class<?> beanClass) {
        LocalDate minDate = LocalDate.parse("2000-01-01");
        LocalDate endDate = LocalDate.parse("2017-12-31");
        LocalDateTime minDateTime = minDate.atStartOfDay();
        // Only values representing the start of the day are being generated when omitting .minusNanos(1L)!
        LocalDateTime endDateTime = endDate.plusDays(1).atStartOfDay().minusNanos(1L);
        final Randomizer<LocalDateTime> randomizer1 = LocalDateTimeRangeRandomizer.aNewLocalDateTimeRangeRandomizer(minDateTime, endDateTime);
        Randomizer<String> randomizer2 = new FixedValuesRandomizer<String>(values);
        EnhancedRandom random = 
                EnhancedRandomBuilder.aNewEnhancedRandomBuilder()
                .charset(StandardCharsets.UTF_8)
                .dateRange(minDate, endDate)
                .randomize(LocalDateTime.class, randomizer1)
                .collectionSizeRange(1, 5)
                .overrideDefaultInitialization(true)
                .exclude(de.lisaplus.util.notify.ChangePublisher.class)
                .exclude(DaoContext.class)
                .exclude(FieldDefinitionBuilder.field().named("tenantId").ofType(String.class).get())
                .stringLengthRange(5,10)
                .randomize(FieldDefinitionBuilder.field().named(propName).ofType(propClass).inClass(beanClass).get(), randomizer2)
                .build();
        return random;
    }

    @Test
    public void dummyTest() {
        assertTrue("Dummy test", true);
    }
    """
        println fileHead

        // Generate tests for string properties (not array!), storing them in allLines!
        allLines.clear()
        prepareStacks.call()
        findStringProps(type, allLines)

        // Append tests to output
        allLines.each { println it }

        println('}')    // last line, close class!
    }
}
