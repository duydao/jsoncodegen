package de.lisaplus.atlas

import de.lisaplus.atlas.builder.JsonSchemaBuilder
import de.lisaplus.atlas.codegen.GeneratorBase
import de.lisaplus.atlas.interf.IModelBuilder
import de.lisaplus.atlas.model.Model
import de.lisaplus.atlas.model.Property
import de.lisaplus.atlas.model.Type

class FuzzyFilterExperiment {

    static main(args) {

        def base = '/home/stefan/Entwicklung/service-op-message/models/models-lisa-server/model/'
        def modelPath = args.length == 0 ?
                base + 'op_message.json'
                : args[0]
        def typeName = args.length > 0 ?
                args[1]
                : 'ObjectGroup' // 'OpMessage' // 'OpMessageJoined'

        def fuzzyExp = new FuzzyFilterExperiment(modelPath)
        fuzzyExp.execute(typeName, typeName.endsWith('Joined'))

        // Check for exception while running code generation for all available types
        fuzzyExp.generateAll()
    }

    /** The path to the model definition file */
    String modelPath = modelPath
    /** The complete model with all types */
    Model model
    /** The bindings of the template / code generation */
    Map data
    /** Indicates whether the current type is a joined type */
    boolean joined
    /** The name of the Java class, which is being processed. */
    String targetType
    /** The name of the Java class, which is being processed, without suffix 'Joined'! */
    String targetTypeNotJoined
    /** This stack holds the property (names) visited while traversing the object hierarchy.*/
    List<Property> propStack = []
    /** Indicates that this property is an array. This sack is build while traversing the object hierarchy. */
    List<Boolean> propIsArrayStack = []
    /** The name of the Java class, which holds the property. This sack is build while traversing the object hierarchy. */
    List<String> parentJavaClass = []
    /** Same as parentJavaClass, but the very first entry without suffix 'Joined' */
    List<String> parentJavaClassNotJoined = []
    /**
     *  Indicates that this property or any of its parents was an array and that we therefore have to process an collection.
     *  This sack is build while traversing the object hierarchy.
     */
    List<Boolean> propIsCollectionStack = []
    /** For caching the lines generated by the (recursive) closure calls of the model loops! */
    List<String> allLines = []
    /** For enabling/disabling debug output */
    boolean verbose = false

    // Closures, which will end up at the start of the templates!
    /**
     * Prepares the stacks for running the next loop over the model
     */
    def prepareStacks = {
        propStack.clear()
        propIsArrayStack.clear()
        // avoid extra case for handling empty stack!
        propIsCollectionStack = [false]
        parentJavaClass.clear()
        parentJavaClassNotJoined.clear()
    }

    /**
     * Adds new elements to the stacks
     * @param property The property, which is to be visited
     */
    def putStacks = { Property property ->
        if (propStack.empty) {
            parentJavaClass.add(targetType)
            parentJavaClassNotJoined.add(targetTypeNotJoined)
        } else {
            if (verbose) {
                def pClassName = propStack.last().type.type.name;
                println "// prop=${property.name} parentClas=${pClassName}"
            }
            parentJavaClass.add(data.upperCamelCase.call(propStack.last().type.type.name))
            parentJavaClassNotJoined.add(data.upperCamelCase.call(propStack.last().type.type.name))
        }
        propStack.add(property)
        propIsArrayStack.add(property.type.isArray)
        // If either already collection of if this property is an collection.
        propIsCollectionStack.add(propIsCollectionStack.last() || property.type.isArray)
    }

    /**
     * Pops the latest elements from the stacks
     */
    def popStacks = {
        propStack.pop()
        propIsArrayStack.pop()
        propIsCollectionStack.pop()
        parentJavaClass.pop()
        parentJavaClassNotJoined.pop()
    }

    // findStringProps calls itself, needs forward declaration in template!
    /**
     * Finds the relevant String properties of the current type, calls itself for complex inner types!
     */
    def findStringProps = { Type type, List<String> lines ->
        // loop over string properties (not array!)
        type.properties.findAll { prop -> prop.type.class.getSimpleName() == 'StringType' && ! prop.type.isArray } .each { prop ->
            propStack.add(prop)
            if (verbose) {
                def key = propStack.collect { prop2 -> prop2.name }.join('.')
                println "    // name=${prop.name} key=$key type=${prop.type.class.getSimpleName()} isArray=${prop.type.isArray}"
            }
            propStack.pop()
            createFuzzyTest(prop, lines)
        }

        // no recursive calls for now!
        data.filterProps.call(type, [refComplex:true, array:false, withoutTag:'notDisplayed']).each { Property prop ->
            // recursive call!
            putStacks.call(prop)
            findStringProps.call(prop.type.type, lines)
            popStacks.call()
        }
    }

    /**
     * Appends lines of a test method for a relevant String property to parameter lines!
     */
    def createFuzzyTest = { Property property, List<String> lines ->
        // copy stacks before adding current property
        def shortPropStack = propStack.clone()
        def shortParentJavaClass = parentJavaClass.clone()
        def shortParentJavaClassNotJoined = parentJavaClassNotJoined.clone()


        def prefix = '\n                        '
        def mapLines = ''
        def mapLinesNotJoined = ''
        def mapLinesParent = ''
        def propParentClass
        if (propStack.isEmpty()) {
            propParentClass = targetTypeNotJoined
        } else {
            propParentClass = data.upperCamelCase.call(propStack.last().type.typeName)
        }
        if (propParentClass == 'ListEntry' && property.name == 'refId') {
            // Skip testing of ListEntry.refId: The properties values will be overwritten by DaoXXX.insert() with the
            // GUID of referenced objects!
            return
        }
        putStacks.call(property)
        def key = propStack.collect {prop -> prop.name}.join('.')
        def lowerProp = data.lowerCamelCase.call(property.name)
        def upperProp = data.upperCamelCase.call(property.name)
        def parentStart
        if (key.startsWith('objectBase.')) {
            parentStart = 'arrBaseDao'
        } else {
            parentStart = 'arrDao'
        }
        // case 1: DaoOpMessage (stack depth 1)
        // case 2: DaoObjectBase (stack depth 2 and key starts with objectBase
        // case 3: No prefix Dao - Use parentJavaClass.last() unchanged!
        def parentClass = parentJavaClass.last()
        switch (parentJavaClass.size()) {
            case 1:
                parentClass = 'Dao' + targetTypeNotJoined
            break
            case 2:
                if (key.startsWith('objectBase.')) {
                    parentClass = 'DaoObjectBase'
                }
            break
        }
        if (key.startsWith('objectBase.') && shortPropStack.size > 1) {
            def propIter = shortPropStack.iterator()
            def classIter = shortParentJavaClass.iterator()
            def firstProp = propIter.next()
            def firstClass = classIter.next()
            assert firstProp.name == 'objectBase' && firstClass == targetType : "firstProp=${firstProp.name}, targetType=${targetType}"
            assert targetType.endsWith('Joined') : targetType
            while (propIter.hasNext()) {
                def clazz = classIter.next()
                def getter = '::get' + data.upperCamelCase.call(propIter.next().name)
                mapLinesParent += "${prefix}.map(${clazz}${getter})"
            }
        }
        if (!key.startsWith('objectBase.') && shortPropStack.size > 0 ) {
            def propIter = shortPropStack.iterator()
            def classIter = shortParentJavaClassNotJoined.iterator()
            while (propIter.hasNext()) {
                def clazz = classIter.next()
                def getter = '::get' + data.upperCamelCase.call(propIter.next().name)
                mapLinesParent += "${prefix}.map(${clazz}${getter})"
            }
        }

        if (key.startsWith('objectBase.')) {
            // special case for string properties attached to inner ObjectBase!
            def propIter = propStack.iterator()
            def classIter = parentJavaClass.iterator()
            def classNotJoinedIter = parentJavaClassNotJoined.iterator()
            def firstProp = propIter.next()
            def firstClass = classIter.next()
            def firstClassNotJoined = classNotJoinedIter.next()
            assert firstProp.name == 'objectBase' && firstClass == targetType && firstClassNotJoined == targetTypeNotJoined : "firstProp=${firstProp.name}, firstClass=${firstClass}, firstClassNotJoined=${firstClassNotJoined}"
            assert targetType.endsWith('Joined') : targetType
            // get corresponding XXXJoined object to be able to collect the string values residing in the ObjectBase!
            mapLinesNotJoined += "${prefix}.map(dao -> Dao${targetType}.byId(dao.getGuid(), testContext))"
            mapLinesNotJoined += "${prefix}.map(${targetType}::getObjectBase)"
            mapLines += "${prefix}.map(${firstClass}::getObjectBase)"
            while (propIter.hasNext()) {
                def clazz = classIter.next()
                def clazzNotJoined = classNotJoinedIter.next()
                def getter = '::get' + data.upperCamelCase.call(propIter.next().name)
                mapLines += "${prefix}.map(${clazz}${getter})"
                mapLinesNotJoined += "${prefix}.map(${clazzNotJoined}${getter})"
            }
        } else {
            def propIter = propStack.iterator()
            def classIter = parentJavaClass.iterator()
            def classNotJoinedIter = parentJavaClassNotJoined.iterator()
            while (propIter.hasNext()) {
                def clazz = classIter.next()
                def clazzNotJoined = classNotJoinedIter.next()
                def getter = '::get' + data.upperCamelCase.call(propIter.next().name)
                mapLines += "${prefix}.map(${clazz}${getter})"
                mapLinesNotJoined += "${prefix}.map(${clazzNotJoined}${getter})"
            }
        }
        // ensure unique method names
        def methodName = propStack.collect {prop -> data.upperCamelCase.call(prop.name)}.join('')
        lines.add("""
    @Test
    public void testSearch${methodName}() {
        // final List<Dao${targetTypeNotJoined}> daos =  createInsertDaos("${lowerProp}", String.class, ${propParentClass}.class); // not specific enough!

        final BiConsumer<Dao${targetTypeNotJoined}[], DaoObjectBase[]> valueSetter = (arrDao, arrBaseDao) -> {
            final List<$parentClass> parents = Arrays.stream($parentStart)$mapLinesParent
                    .collect(Collectors.toList());
            assert parents.size() % values.length == 0;
            int idx = 0;
            for ($parentClass parent : parents) {
                parent.set$upperProp(values[idx++]);
                if (idx == values.length) {
                    idx = 0;
                }
            }
        };
        final List<Dao${targetTypeNotJoined}> daos = createInsertDaos(valueSetter);
        final List<String> actValues1 = daos.stream()${mapLinesNotJoined}
                        .collect(Collectors.toList());
        assertEquals(values.length, actValues1.size());
        assertTrue(actValues1.toString(), actValues1.containsAll(Arrays.asList(values)));

        try {
            final String sort = null;
            final String key = "$key";
            textPatter2Matches.entrySet().forEach( entry -> {
                final String pattern = entry.getKey();
                final List<String> expValues = entry.getValue();
                final String filter = String.format(" { \\"%s\\" : { \\"text\\": \\"%s\\"}}", key, pattern);
                final List<String> actValues = Dao${targetType}.list(testContext, 0, 0, filter, sort)
                        .stream()${mapLines}
                        .collect(Collectors.toList());
                assertEquals(String.format("%s: %s", pattern, actValues), expValues.size(), actValues.size());
                assertTrue(String.format("%s: %s", pattern, actValues), actValues.containsAll(expValues));
            });
            regexPatter2Matches.entrySet().forEach( entry -> {
                final String pattern = entry.getKey();
                final List<String> expValues = entry.getValue();
                final String filter = String.format(" { \\"%s\\" : { \\"regex\\": \\"%s\\"}}", key, pattern);
                final List<String>  actValues = Dao${targetType}.list(testContext, 0, 0, filter, sort)
                        .stream()${mapLines}
                        .collect(Collectors.toList());
                assertEquals(String.format("%s: %s", pattern, actValues), expValues.size(), actValues.size());
                assertTrue(String.format("%s: %s", pattern, actValues), actValues.containsAll(expValues));
            });
        } finally {
            // clean up to avoid interfering with other tests!
            for (Dao${targetTypeNotJoined} dao : daos) {
                dao.delete();
            }
        }
    }""")
        popStacks.call()
    }

    // constructor and methods.
    FuzzyFilterExperiment(modelPath) {
        this.modelPath = modelPath
        this.model = readModel(modelPath)
    }

    private Model readModel(String modelPath) {
        def modelFile = new File(modelPath)
        IModelBuilder builder = new JsonSchemaBuilder()
        return builder.buildModel(modelFile)
    }

    /**
     * Execute code generation for all types
     */
    void generateAll() {
        GeneratorBase generator = new DummyGenerator()
        // first process normal types
        this.model = readModel(modelPath)
        data = generator.createTemplateDataMap(model)
        def relevantTypes = model.types.findAll { type -> data.containsTag.call(type, 'mongodb') || type.name.endsWith('Joined') }
        def normalTypes = relevantTypes.findAll { type -> !type.name.endsWith('Joined')}.collect()
        for (Type type : normalTypes) {
            if (verbose) println 'Not joined: ' + type.name
            executeForType(type, false)
        }
        // then reload model to erase effects of type tuning and process joined types
        this.model = readModel(modelPath)
        data = generator.createTemplateDataMap(model)
        def joinedTypes = relevantTypes.findAll { type -> type.name.endsWith('Joined')}.collect()
        for (Type type : joinedTypes) {
            if (verbose) println 'Joined: ' + type.name
            executeForType(type, true)
        }
    }

    /**
     * Prepares and request code generation for one type
     * @param typeName The name of the type, which is to be processed
     * @param joined Indicates whether that type is a joined type
     */
    void execute(String typeName, boolean joined) {
        GeneratorBase generator = new DummyGenerator()
        data = generator.createTemplateDataMap(model)
        Type type = data.model.types.find {type -> type.name == typeName}
        executeForType(type, joined)
    }

    /**
     * Execute code generation for one type
     * @param currentType The type, which is to be processed
     * @param joined Indicates whether that type is a joined type
     */
    private void executeForType(Type currentType, boolean joined) {
        this.joined = joined
        targetType = data.upperCamelCase.call(currentType.name)
        println '###################################################################'
        println "Start of $targetType:"
        println '###################################################################'


        def extraParam = ['serviceBase' : 'opMessage']

        def daoImport = "import de.lisaplus.lisa.${extraParam.serviceBase}.dao.*;"
        if (joined) {
            daoImport += "\nimport de.lisaplus.lisa.${extraParam.serviceBase}.dao.joined.*;"
        }
        targetTypeNotJoined = targetType.endsWith("Joined") ? targetType.replace('Joined', '') : targetType

        String createInstanceDaosNoObjectBase= """        // $targetType is not associated with an ObjectBase!
        final DaoObjectBase[] arrBaseDao = null;
        final Dao$targetTypeNotJoined[] arrDao = IntStream.range(0, values.length)
                .mapToObj(in -> random.nextObject(Dao${targetTypeNotJoined}.class))
                .toArray(Dao$targetTypeNotJoined[]::new);
        // set fixed values for a single string property
        valueSetter.accept(arrDao, arrBaseDao);
        
        IntStream.range(0, values.length).forEach(i -> {

            // currently tenantId only gets overwritten in setDaoContext(DaoContext) when it is still null!
            Dao$targetTypeNotJoined dao = arrDao[i];
            dao.setDaoContext(testContext);
            // When EnhancedRandom starts creating fraction of seconds, then all DateTimeType properties must be processed!
            // x.setCreated(toStartOfSecond(x.getCreated()))
            dao.insert();
        });
        return Arrays.asList(arrDao);"""

        String createInstanceDaosWithObjectBase= """        final DaoObjectBase[] arrBaseDao = IntStream.range(0, values.length)
                .mapToObj(in -> random.nextObject(DaoObjectBase.class))
                .toArray(DaoObjectBase[]::new);
        final Dao$targetTypeNotJoined[] arrDao = IntStream.range(0, values.length)
                .mapToObj(in -> random.nextObject(Dao${targetTypeNotJoined}.class))
                .toArray(Dao$targetTypeNotJoined[]::new);
        // set fixed values for a single string property
        valueSetter.accept(arrDao, arrBaseDao);

        // persist daos
        IntStream.range(0, values.length).forEach(i -> {

            DaoObjectBase objectBase = arrBaseDao[i];
            objectBase.setDaoContext(testContext);
            // When EnhancedRandom starts creating fraction of seconds, then all DateTimeType properties must be processed!
            // objectBase.setXXX(toStartOfSecond(objectBase.getXXX()))
            objectBase.insert();

            // currently tenantId only gets overwritten in setDaoContext(DaoContext) when it is still null!
            Dao$targetTypeNotJoined dao = arrDao[i];
            dao.setDaoContext(testContext);
            // When EnhancedRandom starts creating fraction of seconds, then all DateTimeType properties must be processed!
            // x.setCreated(toStartOfSecond(x.getCreated()))
            dao.setObjectBaseId(objectBase.getGuid());
            dao.insert();
        });
        return Arrays.asList(arrDao);"""

        // check for attribute objectBase or objectBaseId!
        boolean noObjectBase = currentType.properties.findAll { prop -> prop.name == 'objectBase' || prop.name == 'objectBaseId'}.empty
        String createInstanceDaos = noObjectBase ? createInstanceDaosNoObjectBase : createInstanceDaosWithObjectBase

        String fileHead = """
/*********start*********/
package de.lisaplus.lisa.${extraParam.serviceBase}.fuzzy;

/**
 * This file is generated by jsonCodeGen. Changes will be overwritten with next code generation run.
 * Template: test_fuzzy.txt
 */

import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.function.BiConsumer;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import com.swarco.cip.utils.config.ConfigFactory;
import com.swarco.cip.utils.config.LiveConfig;
import com.swarco.cip.utils.config.impl.PureVarConfig;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import de.lisaplus.FixedValuesRandomizer;
$daoImport
import de.lisaplus.lisa.${extraParam.serviceBase}.model.*;
import de.lisaplus.util.dao.DaoContext;
import de.lisaplus.util.mask.MockPojoMaskService;
import de.lisaplus.util.mongodb.DbFactory;
import io.github.benas.randombeans.EnhancedRandomBuilder;
import io.github.benas.randombeans.FieldDefinitionBuilder;
import io.github.benas.randombeans.api.EnhancedRandom;
import io.github.benas.randombeans.api.Randomizer;
import io.github.benas.randombeans.randomizers.range.LocalDateTimeRangeRandomizer;

/**
 * Integration test for fuzzy search in class Dao$targetType.
 */
public class IT_Fuyyz_Search_Dao_$targetType {

    /** The values to use for the bean properties when generation beans with random beans. */
    private static final String[] values;
    /** Add mapping of text pattern to expected matches. Text query are case insensitive! */
    private static Map<String, List<String>> textPatter2Matches;
    /** Add mapping of regex pattern to expected matches. Regex query are case sensitive! */
    private static Map<String, List<String>>  regexPatter2Matches;
    /** DaoContext to use for this test. */
    static DaoContext testContext;
    /** PojoMaskService embedded into #testContext */
    static MockPojoMaskService maskService;
    /** For creating random test objects. */
    static EnhancedRandom random;

    static {
        values = new String[] { "aber", "Berlin", "Erlangen", "Jena", "Hans", "Mike", " 123456 ", " der hat Leerzeichen ", "", "   ", " Erhard", " niedErmitderIder ",
                null, "EndeAufen", "erStartLow", " soleCaseOfeRyay", " soleCaseOfERyay "};

        textPatter2Matches = new HashMap<>();
        // case insensitive!
        textPatter2Matches.put("er", Arrays.asList("aber", "Berlin", "Erlangen", " der hat Leerzeichen ", " Erhard", " niedErmitderIder ", "erStartLow", " soleCaseOfeRyay", " soleCaseOfERyay "));
        textPatter2Matches.put("Er", Arrays.asList("aber", "Berlin", "Erlangen", " der hat Leerzeichen ", " Erhard", " niedErmitderIder ", "erStartLow", " soleCaseOfeRyay", " soleCaseOfERyay "));
        textPatter2Matches.put("eR", Arrays.asList("aber", "Berlin", "Erlangen", " der hat Leerzeichen ", " Erhard", " niedErmitderIder ", "erStartLow", " soleCaseOfeRyay", " soleCaseOfERyay "));
        textPatter2Matches.put("ER", Arrays.asList("aber", "Berlin", "Erlangen", " der hat Leerzeichen ", " Erhard", " niedErmitderIder ", "erStartLow", " soleCaseOfeRyay", " soleCaseOfERyay "));

        // see e.g. https://stackoverflow.com/questions/3305561/how-to-query-mongodb-with-like
        regexPatter2Matches = new HashMap<>();
        // starts with upper case
        regexPatter2Matches.put("^Er.*", Arrays.asList("Erlangen"));
        // ends with
        regexPatter2Matches.put(".*en\044", Arrays.asList("Erlangen", "EndeAufen"));
        // lower case anywhere
        regexPatter2Matches.put(".*er.*", Arrays.asList("aber", "Berlin", " der hat Leerzeichen ", " niedErmitderIder ", "erStartLow"));
        // Upper case anywhere
        regexPatter2Matches.put(".*Er.*", Arrays.asList("Erlangen", " Erhard", " niedErmitderIder "));
        // Case not present!
        regexPatter2Matches.put("eR", Arrays.asList(" soleCaseOfeRyay"));
        // Case not present!
        regexPatter2Matches.put("ER", Arrays.asList(" soleCaseOfERyay "));
    }

    @BeforeClass
    public static void before() {
        System.out.println("*********************** IT_Fuyyz_Search_Dao_$targetType - Start ***********************");
        LiveConfig liveConfig = ConfigFactory.getInst().getConfig();
        if (liveConfig==null) {
            System.out.println("set new LiveConfig instance");
            liveConfig = new PureVarConfig();
            ConfigFactory.getInst().setConfig(liveConfig);
            if (System.getenv("MONGODB_ADDRESS")==null)
                System.setProperty("MONGODB_ADDRESS","localhost");
            if (System.getenv("MONGODB_PORT")==null)
                System.setProperty("MONGODB_PORT","30001");
            DbFactory.getInst().reinit();
        }

        final String tenantId = String.format("test_tenant_%s", UUID.randomUUID().toString());
        testContext = new DaoContext(tenantId, "Junit-Test");
        maskService = new MockPojoMaskService();
        testContext.setMaskService(maskService);

        LocalDate minDate = LocalDate.parse("2000-01-01");
        LocalDate endDate = LocalDate.parse("2017-12-31");
        LocalDateTime minDateTime = minDate.atStartOfDay();
        // Only values representing the start of the day are being generated when omitting .minusNanos(1L)!
        LocalDateTime endDateTime = endDate.plusDays(1).atStartOfDay().minusNanos(1L);
        final Randomizer<LocalDateTime> randomizer1 = LocalDateTimeRangeRandomizer.aNewLocalDateTimeRangeRandomizer(minDateTime, endDateTime);
        random = EnhancedRandomBuilder.aNewEnhancedRandomBuilder()
                .charset(StandardCharsets.UTF_8)
                .dateRange(minDate, endDate)
                .randomize(LocalDateTime.class, randomizer1)
                .collectionSizeRange(values.length, values.length)
                .overrideDefaultInitialization(true)
                .exclude(de.lisaplus.util.notify.ChangePublisher.class)
                .exclude(DaoContext.class)
                .exclude(FieldDefinitionBuilder.field().named("tenantId").ofType(String.class).get())
                .stringLengthRange(5,10)
                .build();
    }

    @AfterClass
    public static void after() {
        System.out.println("*********************** IT_Fuyyz_Search_Dao_$targetType - End ***********************");
    }

    /**
     * Creates a collection of Dao instances and adds them to the storage back-end.
     * @param valueSetter This object can be used to ensure that the values associated with one attribute of the object
     *            will be forced to represent the {@link #values}.
     * @return The new Dao instances
     */
    private List<Dao$targetTypeNotJoined> createInsertDaos(BiConsumer<Dao$targetTypeNotJoined[], DaoObjectBase[]> valueSetter) {
${createInstanceDaos}
    }

    @Test
    public void dummyTest() {
        assertTrue("Dummy test", true);
    }
"""
        println fileHead

        // Generate tests for string properties (not array!), storing them in allLines!
        allLines.clear()
        prepareStacks.call()
        findStringProps(currentType, allLines)

        // Append tests to output
        allLines.each { println it }

        println('}')    // last line, close class!
    }
}
